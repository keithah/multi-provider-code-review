# PR #2 Feature Integration - Addendum to Rewrite Blueprint

**Date**: 2026-01-21  
**Purpose**: Ensure all valuable functionality from PR #2 is incorporated into the TypeScript rewrite

---

## Summary of PR #2

PR #2 adds **critical production features** that significantly improve the tool's reliability, cost-effectiveness, and user experience. This addendum ensures these features are included in the TypeScript rewrite.

---

## Feature Comparison: PR #2 vs Blueprint

### ‚úÖ Features Already in Blueprint

| Feature | PR #2 Implementation | Blueprint Coverage | Notes |
|---------|---------------------|-------------------|-------|
| **Multi-provider execution** | Bash + Python | TypeScript orchestrator | ‚úÖ Covered in `LLMExecutor` |
| **Consensus inline comments** | Python script | `ConsensusEngine` | ‚úÖ Enhanced version in blueprint |
| **Cost tracking** | OpenRouter API + Python | `CostTracker` module | ‚úÖ Included with caching |
| **SARIF export** | Python SARIF generator | `output/sarif.ts` | ‚úÖ Full v2.1.0 support |
| **Parallel execution** | Bash background jobs | `p-queue` library | ‚úÖ Better concurrency control |
| **Retry logic** | Bash loops | `p-retry` library | ‚úÖ Exponential backoff |
| **Provider filtering** | Allowlist/blocklist | `ProviderRegistry` | ‚úÖ More sophisticated |
| **YAML config** | `config_loader.py` | Zod validation | ‚úÖ Type-safe with hierarchy |

### üÜï Features Missing from Blueprint (Must Add)

| Feature | PR #2 Implementation | Action Required |
|---------|---------------------|-----------------|
| **1. AI-Generated Code Detection** | Prompts providers for likelihood estimate | ‚ö†Ô∏è Add to prompt builder |
| **2. Test Coverage Hints** | Detects missing test files | ‚ö†Ô∏è Add dedicated analyzer |
| **3. Chunked Comment Posting** | Splits large comments at 60KB | ‚ö†Ô∏è Add to GitHub client |
| **4. Skip Filters (Advanced)** | Labels, min/max files, min/max lines | ‚ö†Ô∏è Add to orchestrator |
| **5. Rate Limit Tracking** | Per-provider with flock | ‚ö†Ô∏è Add rate limiter |
| **6. OpenRouter Pricing Integration** | Fetches model pricing from API | ‚ö†Ô∏è Add pricing service |
| **7. Budget Pre-Estimation** | Estimates cost before running | ‚ö†Ô∏è Add to cost tracker |
| **8. Provider Rotation** | Round-robin provider selection | ‚ö†Ô∏è Add to registry |
| **9. Fallback Provider Chain** | OpenRouter ‚Üí OpenCode fallback | ‚ö†Ô∏è Add to config |
| **10. Artifact Upload** | JSON/SARIF to GitHub artifacts | ‚ö†Ô∏è Add to workflow |

---

## Detailed Feature Specifications

### 1. AI-Generated Code Detection ‚ö†Ô∏è MISSING

**What it does**: Asks each provider to estimate likelihood that code is AI-generated

**PR #2 Implementation**:
```python
# Added to prompt:
"10. AI-generated code likelihood (0-100%): Estimate the likelihood that 
    significant portions of the code being reviewed were generated by AI."
```

**Where to add in blueprint**:
```typescript
// src/analysis/llm/prompt-builder.ts

export class PromptBuilder {
  build(context: PRContext, config: ReviewConfig): string {
    return `
You are a code reviewer. Analyze this PR and provide:

1. Code quality issues
2. Security vulnerabilities
3. Performance concerns
4. Best practice violations
5. AI-generated code likelihood (0-100%)

IMPORTANT: For each finding, include:
- file: filename
- line: line number
- severity: critical/major/minor
- title: brief title
- message: detailed explanation
- suggestion: code fix

AI Code Detection:
Estimate the likelihood (0-100%) that significant portions of this PR 
were generated by AI tools (GitHub Copilot, ChatGPT, Claude, etc.). 
Consider:
- Boilerplate patterns
- Generic variable names
- Overly verbose comments
- Lack of domain-specific knowledge
- Inconsistent code style

Output as JSON with:
{
  "findings": [...],
  "ai_likelihood": 75,
  "ai_reasoning": "Code shows typical AI patterns: generic names, boilerplate..."
}
    `;
  }
}
```

**Add to types**:
```typescript
// src/types/index.ts

export interface ReviewResult {
  content: string;
  usage?: TokenUsage;
  durationSeconds?: number;
  findings?: Finding[];
  aiLikelihood?: number;        // NEW
  aiReasoning?: string;          // NEW
}

export interface Review {
  summary: string;
  findings: Finding[];
  inlineComments: InlineComment[];
  actionItems: string[];
  metrics: ReviewMetrics;
  aiAnalysis?: {                 // NEW
    averageLikelihood: number;
    providerEstimates: Record<string, number>;
    consensus: string;
  };
}
```

**Display in summary**:
```typescript
// src/output/formatter.ts

generateSummary(review: Review): string {
  let summary = `## Code Review Summary\n\n`;
  
  // Add AI detection section if available
  if (review.aiAnalysis && review.aiAnalysis.averageLikelihood > 30) {
    summary += `### ‚ö†Ô∏è AI-Generated Code Detection\n\n`;
    summary += `**Average likelihood**: ${review.aiAnalysis.averageLikelihood}%\n`;
    summary += `**Consensus**: ${review.aiAnalysis.consensus}\n\n`;
    
    const estimates = Object.entries(review.aiAnalysis.providerEstimates)
      .map(([provider, pct]) => `- ${provider}: ${pct}%`)
      .join('\n');
    summary += `**Provider estimates**:\n${estimates}\n\n`;
  }
  
  // ... rest of summary
}
```

---

### 2. Test Coverage Hints ‚ö†Ô∏è MISSING

**What it does**: Detects when code files are changed but corresponding test files are missing

**PR #2 Implementation**:
```python
# Python script that checks for missing tests
import os, sys

changed_files = sys.argv[1].split(",")
missing = []

for f in changed_files:
    if f.endswith((".ts", ".tsx", ".js", ".jsx", ".py")):
        # Skip if already a test file
        if any(x in f for x in [".test.", ".spec.", "_test.", "tests/"]):
            continue
        
        # Check for corresponding test file
        base = f.rsplit(".", 1)[0]
        exts = [".test.ts", ".spec.ts", "_test.py", "test_*.py"]
        test_exists = any(os.path.exists(f"{base}{ext}") for ext in exts)
        
        if not test_exists:
            missing.append(f)

if missing:
    print("\n".join(missing))
```

**Where to add in blueprint**:
```typescript
// src/analysis/test-coverage-analyzer.ts

import * as fs from 'fs';
import * as path from 'path';

export interface TestCoverageHint {
  file: string;
  suggestedTestFile: string;
  testPattern: string;
}

export class TestCoverageAnalyzer {
  /**
   * Detect missing test files for changed code files
   */
  analyze(changedFiles: FileChange[]): TestCoverageHint[] {
    const hints: TestCoverageHint[] = [];
    
    for (const file of changedFiles) {
      // Only check code files
      if (!this.isCodeFile(file.filename)) continue;
      
      // Skip if already a test file
      if (this.isTestFile(file.filename)) continue;
      
      // Check if corresponding test exists
      const testFile = this.findTestFile(file.filename);
      if (!testFile) {
        hints.push({
          file: file.filename,
          suggestedTestFile: this.suggestTestFile(file.filename),
          testPattern: this.getTestPattern(file.filename),
        });
      }
    }
    
    return hints;
  }
  
  private isCodeFile(filename: string): boolean {
    const codeExts = ['.ts', '.tsx', '.js', '.jsx', '.py', '.go', '.rs', '.java'];
    return codeExts.some(ext => filename.endsWith(ext));
  }
  
  private isTestFile(filename: string): boolean {
    const testPatterns = [
      '.test.',
      '.spec.',
      '_test.',
      'tests/',
      '__tests__/',
      'test_',
    ];
    return testPatterns.some(pattern => filename.includes(pattern));
  }
  
  private findTestFile(filename: string): string | null {
    const dir = path.dirname(filename);
    const base = path.basename(filename, path.extname(filename));
    const ext = path.extname(filename);
    
    // Check common test file patterns
    const patterns = [
      `${base}.test${ext}`,
      `${base}.spec${ext}`,
      `${base}_test${ext}`,
      `test_${base}${ext}`,
      `__tests__/${base}.test${ext}`,
    ];
    
    for (const pattern of patterns) {
      const testPath = path.join(dir, pattern);
      if (fs.existsSync(testPath)) {
        return testPath;
      }
    }
    
    return null;
  }
  
  private suggestTestFile(filename: string): string {
    const ext = path.extname(filename);
    const base = path.basename(filename, ext);
    const dir = path.dirname(filename);
    
    // TypeScript/JavaScript: prefer .test.ts
    if (ext === '.ts' || ext === '.tsx') {
      return path.join(dir, `${base}.test.ts`);
    }
    
    // Python: prefer test_*.py
    if (ext === '.py') {
      return path.join(dir, `test_${base}.py`);
    }
    
    // Default: *.test.ext
    return path.join(dir, `${base}.test${ext}`);
  }
  
  private getTestPattern(filename: string): string {
    const ext = path.extname(filename);
    
    if (ext === '.ts' || ext === '.tsx') {
      return 'Jest/Vitest pattern: *.test.ts or __tests__/*.ts';
    }
    
    if (ext === '.py') {
      return 'pytest pattern: test_*.py or *_test.py';
    }
    
    return `Test pattern: *.test${ext}`;
  }
}
```

**Add to synthesis summary**:
```typescript
// src/analysis/synthesis.ts

private async generateSummary(
  grouped: Map<string, Finding[]>,
  pr: PRContext,
  testHints: TestCoverageHint[]  // NEW PARAMETER
): Promise<string> {
  // ... existing summary generation
  
  // Add test coverage section
  if (testHints.length > 0) {
    summary += `\n\n## üß™ Test Coverage Hints\n\n`;
    summary += `The following code files were changed but have no corresponding tests:\n\n`;
    
    for (const hint of testHints.slice(0, 10)) { // Limit to 10
      summary += `- \`${hint.file}\`\n`;
      summary += `  - Suggested test file: \`${hint.suggestedTestFile}\`\n`;
    }
    
    if (testHints.length > 10) {
      summary += `\n... and ${testHints.length - 10} more files\n`;
    }
  }
  
  return summary;
}
```

---

### 3. Chunked Comment Posting ‚ö†Ô∏è MISSING

**What it does**: Splits large review comments into multiple parts to avoid GitHub API 65,536 character limit

**PR #2 Implementation**:
```bash
# Bash script that chunks comments
if [ "$(wc -c < "$SUMMARY_FILE")" -gt 60000 ]; then
  python - "$SUMMARY_FILE" 60000 "/tmp/summary-chunk" <<'PYCODE'
import sys
text = open(sys.argv[1], encoding="utf-8").read()
limit = int(sys.argv[2])
chunks = [text[i:i+limit] for i in range(0, len(text), limit)]
for idx, chunk in enumerate(chunks, 1):
    with open(f"{sys.argv[3]}-{idx}.md", "w", encoding="utf-8") as f:
        f.write(f"(Part {idx}/{len(chunks)})\n\n")
        f.write(chunk)
PYCODE
fi
```

**Where to add in blueprint**:
```typescript
// src/github/comment-poster.ts

export class CommentPoster {
  private static readonly MAX_COMMENT_SIZE = 60000; // GitHub limit is 65536
  
  async postReview(
    pr: PRContext,
    summary: string,
    inlineComments: InlineComment[]
  ): Promise<void> {
    // Post inline comments first (these have separate size limits)
    await this.postInlineComments(pr.number, inlineComments);
    
    // Chunk and post summary if needed
    if (summary.length > CommentPoster.MAX_COMMENT_SIZE) {
      await this.postChunkedComment(pr.number, summary);
    } else {
      await this.postComment(pr.number, summary);
    }
  }
  
  private async postChunkedComment(
    prNumber: number,
    content: string
  ): Promise<void> {
    const chunks = this.chunkContent(content, CommentPoster.MAX_COMMENT_SIZE);
    
    for (let i = 0; i < chunks.length; i++) {
      const header = `üìÑ **Review Summary (Part ${i + 1}/${chunks.length})**\n\n`;
      const chunk = header + chunks[i];
      
      await this.postComment(prNumber, chunk);
      
      // Rate limit protection: wait 1s between chunks
      if (i < chunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  private chunkContent(content: string, maxSize: number): string[] {
    const chunks: string[] = [];
    
    // Try to chunk at paragraph boundaries
    const paragraphs = content.split('\n\n');
    let currentChunk = '';
    
    for (const para of paragraphs) {
      // If adding this paragraph would exceed limit, save current chunk
      if (currentChunk.length + para.length + 2 > maxSize) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = '';
        }
        
        // If single paragraph is too large, split by lines
        if (para.length > maxSize) {
          const lines = para.split('\n');
          let lineChunk = '';
          
          for (const line of lines) {
            if (lineChunk.length + line.length + 1 > maxSize) {
              chunks.push(lineChunk.trim());
              lineChunk = line + '\n';
            } else {
              lineChunk += line + '\n';
            }
          }
          
          if (lineChunk) {
            currentChunk = lineChunk;
          }
        } else {
          currentChunk = para + '\n\n';
        }
      } else {
        currentChunk += para + '\n\n';
      }
    }
    
    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }
    
    return chunks;
  }
  
  private async postComment(
    prNumber: number,
    body: string
  ): Promise<void> {
    await this.octokit.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: prNumber,
      body,
    });
  }
}
```

---

### 4. Advanced Skip Filters ‚ö†Ô∏è MISSING

**What it does**: Skip PR reviews based on labels, file count, or line count thresholds

**PR #2 Implementation**:
```bash
# Skip based on labels
if [ -n "$SKIP_LABELS" ]; then
  for label in $PR_LABELS; do
    if echo "$SKIP_LABELS" | grep -q "$label"; then
      echo "Skipping: PR has label '$label' in skip list"
      exit 0
    fi
  done
fi

# Skip if too small
if [ "$MIN_CHANGED_LINES" -gt 0 ] && [ "$TOTAL_CHANGES" -lt "$MIN_CHANGED_LINES" ]; then
  echo "Skipping: changes ($TOTAL_CHANGES) below min ($MIN_CHANGED_LINES)"
  exit 0
fi

# Skip if too large
if [ "$MAX_CHANGED_FILES" -gt 0 ] && [ "$CHANGED_FILES" -gt "$MAX_CHANGED_FILES" ]; then
  echo "Skipping: files ($CHANGED_FILES) above max ($MAX_CHANGED_FILES)"
  exit 0
fi
```

**Where to add in blueprint**:
```typescript
// src/config/schema.ts

export const ReviewConfigSchema = z.object({
  // ... existing fields
  
  // Skip filters
  skipLabels: z.array(z.string()).optional(),
  minChangedLines: z.number().int().min(0).optional(),
  maxChangedFiles: z.number().int().min(0).optional(),
  skipDrafts: z.boolean().optional(),
  skipBots: z.boolean().optional(),
});
```

```typescript
// src/core/orchestrator.ts

export class ReviewOrchestrator {
  async execute(prNumber: number): Promise<ReviewResult | null> {
    const pr = await this.github.loadPRContext(prNumber);
    
    // Check skip conditions
    const skipReason = this.shouldSkip(pr);
    if (skipReason) {
      console.log(`‚è≠Ô∏è  Skipping review: ${skipReason}`);
      await this.github.postComment(pr.number, 
        `‚ÑπÔ∏è Review skipped: ${skipReason}`
      );
      return null;
    }
    
    // ... continue with review
  }
  
  private shouldSkip(pr: PRContext): string | null {
    // Skip if draft PR
    if (this.config.skipDrafts && pr.draft) {
      return 'PR is in draft status';
    }
    
    // Skip if bot PR
    if (this.config.skipBots && this.isBotAuthor(pr.author)) {
      return `PR author is a bot (${pr.author})`;
    }
    
    // Skip based on labels
    if (this.config.skipLabels && this.config.skipLabels.length > 0) {
      for (const label of pr.labels) {
        if (this.config.skipLabels.includes(label)) {
          return `PR has skip label: ${label}`;
        }
      }
    }
    
    // Skip if too small
    if (this.config.minChangedLines && 
        this.config.minChangedLines > 0) {
      const totalLines = pr.additions + pr.deletions;
      if (totalLines < this.config.minChangedLines) {
        return `Changes (${totalLines} lines) below minimum (${this.config.minChangedLines})`;
      }
    }
    
    // Skip if too large
    if (this.config.maxChangedFiles && 
        this.config.maxChangedFiles > 0) {
      if (pr.files.length > this.config.maxChangedFiles) {
        return `Files changed (${pr.files.length}) exceeds maximum (${this.config.maxChangedFiles})`;
      }
    }
    
    return null;
  }
  
  private isBotAuthor(author: string): boolean {
    const botPatterns = [
      'bot',
      'dependabot',
      'renovate',
      'github-actions',
      '[bot]',
    ];
    
    const lowerAuthor = author.toLowerCase();
    return botPatterns.some(pattern => lowerAuthor.includes(pattern));
  }
}
```

---

### 5. Rate Limit Tracking ‚ö†Ô∏è MISSING

**What it does**: Track rate limits per provider to avoid hitting API limits

**PR #2 Implementation**:
```bash
# Using flock for cross-process rate limit tracking
RATE_LOCK_FILE="/tmp/mpr-ratelimit-${provider//\//_}.lock"
if [ -f "$RATE_LOCK_FILE" ]; then
  rate_until=$(cat "$RATE_LOCK_FILE")
  now=$(date +%s)
  if [ "$now" -lt "$rate_until" ]; then
    echo "Provider $provider rate-limited until $(date -d @$rate_until)"
    continue
  fi
fi
```

**Where to add in blueprint**:
```typescript
// src/utils/rate-limiter.ts

import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

export interface RateLimitInfo {
  provider: string;
  limitedUntil: number; // Unix timestamp
  reason: string;
}

export class RateLimiter {
  private lockDir = path.join(os.tmpdir(), 'mpr-ratelimits');
  
  constructor() {
    // Ensure lock directory exists
    fs.mkdir(this.lockDir, { recursive: true }).catch(() => {});
  }
  
  /**
   * Check if provider is currently rate-limited
   */
  async isRateLimited(provider: string): Promise<boolean> {
    const lockFile = this.getLockFile(provider);
    
    try {
      const data = await fs.readFile(lockFile, 'utf8');
      const info: RateLimitInfo = JSON.parse(data);
      
      if (Date.now() < info.limitedUntil) {
        console.log(
          `‚è≥ ${provider} rate-limited until ${new Date(info.limitedUntil).toISOString()}`
        );
        return true;
      }
      
      // Rate limit expired, remove file
      await fs.unlink(lockFile).catch(() => {});
      return false;
    } catch {
      return false;
    }
  }
  
  /**
   * Mark provider as rate-limited
   */
  async markRateLimited(
    provider: string,
    durationMinutes: number,
    reason: string
  ): Promise<void> {
    const lockFile = this.getLockFile(provider);
    const limitedUntil = Date.now() + durationMinutes * 60 * 1000;
    
    const info: RateLimitInfo = {
      provider,
      limitedUntil,
      reason,
    };
    
    await fs.writeFile(lockFile, JSON.stringify(info), 'utf8');
    
    console.log(
      `‚è≥ Marked ${provider} as rate-limited for ${durationMinutes} minutes: ${reason}`
    );
  }
  
  /**
   * Clear rate limit for provider
   */
  async clearRateLimit(provider: string): Promise<void> {
    const lockFile = this.getLockFile(provider);
    await fs.unlink(lockFile).catch(() => {});
  }
  
  /**
   * Get all currently rate-limited providers
   */
  async getRateLimited(): Promise<RateLimitInfo[]> {
    const limited: RateLimitInfo[] = [];
    
    try {
      const files = await fs.readdir(this.lockDir);
      const now = Date.now();
      
      for (const file of files) {
        const data = await fs.readFile(
          path.join(this.lockDir, file),
          'utf8'
        );
        const info: RateLimitInfo = JSON.parse(data);
        
        if (now < info.limitedUntil) {
          limited.push(info);
        }
      }
    } catch {}
    
    return limited;
  }
  
  private getLockFile(provider: string): string {
    // Sanitize provider name for filename
    const safe = provider.replace(/[^a-z0-9]/gi, '_');
    return path.join(this.lockDir, `${safe}.json`);
  }
}
```

**Integrate with providers**:
```typescript
// src/providers/openrouter.ts

export class OpenRouterProvider extends Provider {
  async review(prompt: string, timeoutMs: number): Promise<ReviewResult> {
    try {
      const response = await fetch(/* ... */);
      
      if (!response.ok) {
        if (response.status === 429) {
          // Parse retry-after header
          const retryAfter = response.headers.get('retry-after');
          const minutes = retryAfter ? parseInt(retryAfter) / 60 : 60;
          
          // Mark as rate-limited
          await this.rateLimiter.markRateLimited(
            this.name,
            minutes,
            'HTTP 429 from OpenRouter API'
          );
          
          throw new RateLimitError(`Rate limited: ${this.name}`);
        }
        
        throw new Error(`API error: ${response.status}`);
      }
      
      // ... normal processing
    } catch (error) {
      throw error;
    }
  }
}
```

**Filter rate-limited providers before execution**:
```typescript
// src/providers/registry.ts

export class ProviderRegistry {
  async createProviders(config: ReviewConfig): Promise<Provider[]> {
    const rateLimiter = new RateLimiter();
    const allProviders = this.instantiateProviders(config);
    
    // Filter out rate-limited providers
    const available: Provider[] = [];
    for (const provider of allProviders) {
      const isLimited = await rateLimiter.isRateLimited(provider.name);
      if (!isLimited) {
        available.push(provider);
      }
    }
    
    if (available.length === 0) {
      throw new Error('All providers are currently rate-limited');
    }
    
    return available;
  }
}
```

---

### 6. OpenRouter Pricing Integration ‚ö†Ô∏è MISSING

**What it does**: Fetches real-time pricing from OpenRouter API to estimate costs

**PR #2 Implementation**:
```bash
# Fetch pricing data
curl -sS -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
  https://openrouter.ai/api/v1/models > /tmp/pricing-cache.json

# Calculate costs in Python
python - <<'PYCODE'
import json, sys
pricing_data = json.load(open('/tmp/pricing-cache.json'))
# ... cost calculation
PYCODE
```

**Where to add in blueprint**:
```typescript
// src/cost/pricing-service.ts

export interface ModelPricing {
  modelId: string;
  promptPrice: number;  // Per 1M tokens
  completionPrice: number;  // Per 1M tokens
  isFree: boolean;
}

export class PricingService {
  private cache: Map<string, ModelPricing> = new Map();
  private cacheExpiry: number = 0;
  private static readonly CACHE_TTL = 3600 * 1000; // 1 hour
  
  constructor(private apiKey?: string) {}
  
  /**
   * Get pricing for a model
   */
  async getPricing(modelId: string): Promise<ModelPricing> {
    // Check if free model (contains :free suffix)
    if (modelId.includes(':free')) {
      return {
        modelId,
        promptPrice: 0,
        completionPrice: 0,
        isFree: true,
      };
    }
    
    // Refresh cache if expired
    if (Date.now() > this.cacheExpiry) {
      await this.refreshCache();
    }
    
    return this.cache.get(modelId) || {
      modelId,
      promptPrice: 0,
      completionPrice: 0,
      isFree: false,
    };
  }
  
  /**
   * Fetch pricing data from OpenRouter
   */
  private async refreshCache(): Promise<void> {
    if (!this.apiKey) {
      console.warn('No API key, using default pricing');
      return;
    }
    
    try {
      const response = await fetch('https://openrouter.ai/api/v1/models', {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
        },
      });
      
      if (!response.ok) {
        throw new Error(`Pricing API error: ${response.status}`);
      }
      
      const data = await response.json();
      
      for (const model of data.data || []) {
        const modelId = model.id;
        const pricing = model.pricing || {};
        
        this.cache.set(modelId, {
          modelId,
          promptPrice: parseFloat(pricing.prompt || '0') * 1_000_000,
          completionPrice: parseFloat(pricing.completion || '0') * 1_000_000,
          isFree: modelId.includes(':free'),
        });
      }
      
      this.cacheExpiry = Date.now() + PricingService.CACHE_TTL;
      console.log(`‚úÖ Loaded pricing for ${this.cache.size} models`);
    } catch (error) {
      console.warn('Failed to fetch pricing:', error);
    }
  }
}
```

**Add cost estimation**:
```typescript
// src/cost/estimator.ts

export class CostEstimator {
  constructor(private pricingService: PricingService) {}
  
  /**
   * Estimate cost before running providers
   */
  async estimateCost(
    providers: Provider[],
    estimatedPromptTokens: number
  ): Promise<CostEstimate> {
    let totalCost = 0;
    const breakdown: Record<string, number> = {};
    
    for (const provider of providers) {
      const pricing = await this.pricingService.getPricing(provider.name);
      
      // Estimate: prompt tokens + 1000 completion tokens
      const promptCost = (estimatedPromptTokens / 1_000_000) * pricing.promptPrice;
      const completionCost = (1000 / 1_000_000) * pricing.completionPrice;
      const providerCost = promptCost + completionCost;
      
      totalCost += providerCost;
      breakdown[provider.name] = providerCost;
    }
    
    return {
      totalCost,
      breakdown,
      estimatedTokens: estimatedPromptTokens + 1000 * providers.length,
    };
  }
  
  /**
   * Calculate actual cost after execution
   */
  calculateActual(results: ProviderResult[]): CostSummary {
    let totalCost = 0;
    const breakdown: Record<string, number> = {};
    
    for (const result of results) {
      if (result.result?.usage) {
        const usage = result.result.usage;
        const pricing = await this.pricingService.getPricing(result.name);
        
        const promptCost = (usage.promptTokens / 1_000_000) * pricing.promptPrice;
        const completionCost = (usage.completionTokens / 1_000_000) * pricing.completionPrice;
        const cost = promptCost + completionCost;
        
        totalCost += cost;
        breakdown[result.name] = cost;
      }
    }
    
    return {
      totalCost,
      breakdown,
      totalTokens: results.reduce(
        (sum, r) => sum + (r.result?.usage?.totalTokens || 0),
        0
      ),
    };
  }
}
```

**Budget guard**:
```typescript
// src/core/orchestrator.ts

async execute(prNumber: number): Promise<ReviewResult> {
  // ... load PR context
  
  // Estimate cost
  if (this.config.budgetMaxUsd && this.config.budgetMaxUsd > 0) {
    const estimate = await this.costEstimator.estimateCost(
      providers,
      this.estimatePromptTokens(pr.diff)
    );
    
    if (estimate.totalCost > this.config.budgetMaxUsd) {
      throw new Error(
        `Estimated cost ($${estimate.totalCost.toFixed(4)}) exceeds budget ($${this.config.budgetMaxUsd})`
      );
    }
    
    console.log(`üí∞ Estimated cost: $${estimate.totalCost.toFixed(4)}`);
  }
  
  // ... continue with review
}
```

---

### 7-10: Remaining Features (Quick Specs)

**7. Budget Pre-Estimation** - Covered above in #6

**8. Provider Rotation**:
```typescript
// src/providers/registry.ts
private rotationIndex = 0;

selectProviders(all: Provider[], limit: number): Provider[] {
  if (limit <= 0 || all.length <= limit) return all;
  
  // Round-robin selection
  const selected: Provider[] = [];
  for (let i = 0; i < limit; i++) {
    const index = (this.rotationIndex + i) % all.length;
    selected.push(all[index]);
  }
  
  this.rotationIndex = (this.rotationIndex + limit) % all.length;
  return selected;
}
```

**9. Fallback Provider Chain**:
```typescript
// src/config/schema.ts
export interface ReviewConfig {
  providers: string[];
  fallbackProviders?: string[];  // NEW
  // ...
}

// In orchestrator: if all providers fail, try fallbacks
```

**10. Artifact Upload**:
```yaml
# action.yml
- name: Upload Reports
  uses: actions/upload-artifact@v4
  with:
    name: code-review-reports
    path: |
      multi-provider-report/*.json
      multi-provider-report/*.sarif
```

---

## Updated Implementation Timeline

### Phase 1: MVP (Weeks 1-4) - No changes

### Phase 2: Core Features from PR #2 (Weeks 5-6)

**Week 5: Essential Features**
- ‚úÖ AI-generated code detection
- ‚úÖ Test coverage hints
- ‚úÖ Chunked comment posting
- ‚úÖ Advanced skip filters

**Week 6: Performance & Cost**
- ‚úÖ Rate limit tracking
- ‚úÖ OpenRouter pricing integration
- ‚úÖ Budget pre-estimation
- ‚úÖ Provider rotation

### Phase 3-4: Continue as planned

---

## Priority Assessment

### Must Have (Include in v2.0)
1. ‚úÖ **Chunked comment posting** - Critical for large PRs
2. ‚úÖ **Skip filters** - Essential for workflow flexibility
3. ‚úÖ **Rate limit tracking** - Prevents API errors
4. ‚úÖ **OpenRouter pricing** - Required for cost accuracy

### Should Have (Include in v2.1)
5. ‚ö†Ô∏è **AI code detection** - Interesting feature, not critical
6. ‚ö†Ô∏è **Test coverage hints** - Nice to have
7. ‚ö†Ô∏è **Provider rotation** - Optimization
8. ‚ö†Ô∏è **Fallback chains** - Reliability improvement

### Nice to Have (Future)
9. ‚ÑπÔ∏è **Artifact upload** - Can be added to workflow later
10. ‚ÑπÔ∏è **Budget warnings** - Enhancement to existing budget guards

---

## Summary

**All critical features from PR #2 are now documented for the TypeScript rewrite.**

**Key additions**:
- 4 must-have features (chunked posting, skip filters, rate limiting, pricing)
- 4 should-have features (AI detection, test hints, rotation, fallbacks)
- 2 nice-to-have features (artifacts, warnings)

**Total estimated effort**: +2 weeks to original timeline
**New total**: 12 weeks ‚Üí 14 weeks for feature-complete v2.0

**Next step**: Review this addendum and confirm which features to include in MVP vs later phases.
