---
phase: 09-integration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - __tests__/integration/path-matcher-performance.integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Performance test with 1000+ files completes in sub-second time"
    - "Cached path matching is faster than uncached (relative comparison)"
    - "PathMatcher handles mixed file patterns efficiently"
    - "Large file sets do not cause memory issues or timeouts"
  artifacts:
    - path: "__tests__/integration/path-matcher-performance.integration.test.ts"
      provides: "PathMatcher caching efficiency validation"
      exports: []
  key_links:
    - from: "__tests__/integration/path-matcher-performance.integration.test.ts"
      to: "src/analysis/path-matcher.ts"
      via: "PathMatcher.determineIntensity()"
      pattern: "determineIntensity"
---

<objective>
Create performance benchmarks that validate PathMatcher caching efficiency with large file sets.

Purpose: Prove that PathMatcher handles 1000+ files efficiently with caching, preventing performance degradation in large PRs. This validates TEST-07 requirement.

Output: `__tests__/integration/path-matcher-performance.integration.test.ts` with performance validation tests.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-integration-testing/09-CONTEXT.md
@.planning/phases/09-integration-testing/09-RESEARCH.md
@__tests__/benchmarks/review-performance.benchmark.ts
@__tests__/unit/analysis/path-matcher.test.ts
@src/analysis/path-matcher.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PathMatcher performance test file</name>
  <files>__tests__/integration/path-matcher-performance.integration.test.ts</files>
  <action>
Create a new performance test file with:

1. **Helper function `generateLargeFileSet(count: number): FileChange[]`**:
   - Generates array of FileChange objects with varied paths
   - Mix of file types to test pattern matching across categories:
     - src/module{i}/index.ts (standard)
     - src/auth/handler{i}.ts (thorough)
     - __tests__/unit/test{i}.test.ts (light)
     - docs/page{i}.md (standard)
     - terraform/resource{i}.tf (thorough)
   - Use modulo to cycle through variants for realistic distribution

2. **Helper function `createMockFileChange(filename: string): FileChange`**:
   - Returns minimal FileChange object with required fields
   - status: 'modified', additions: 1, deletions: 0, changes: 1

3. **First describe block: "PathMatcher caching efficiency"** with tests:

   a. Test "handles 1000 files in sub-second time":
      - Generate 1000 files with generateLargeFileSet(1000)
      - Create PathMatcher with default config, enabled: true
      - Time determineIntensity() call
      - Assert duration < 1000ms (sub-second)
      - Log actual duration for benchmark tracking

   b. Test "second call is faster due to internal caching":
      - Generate 500 files
      - Call determineIntensity() twice with same files
      - Second call should be faster (or equal - cache hit)
      - Use relative comparison, not absolute threshold

   c. Test "handles 5000 files without memory issues":
      - Generate 5000 files
      - Call determineIntensity()
      - Should complete without throwing
      - Duration should be < 5000ms (1ms per file max)

4. **Second describe block: "Pattern matching performance"** with tests:

   a. Test "multiple patterns evaluated efficiently":
      - Use default patterns (auth, test, terraform, etc.)
      - 1000 files with varied paths
      - Verify all patterns evaluated without timeout

   b. Test "complex glob patterns do not cause exponential slowdown":
      - Add a pattern with **/* recursive glob
      - 1000 files
      - Duration should be reasonable (< 2000ms)

5. Use `performance.now()` for timing (higher precision than Date.now()).

6. Mark tests with longer timeouts if needed: `jest.setTimeout(10000)` at top of file.

7. Include a test that verifies result correctness (not just speed):
   - At least some auth files should trigger thorough intensity
   - At least some test files should be matched as light
  </action>
  <verify>
Run `npm test -- __tests__/integration/path-matcher-performance.integration.test.ts` and verify:
- All tests pass
- 1000 file test completes in < 1 second
- 5000 file test completes without OOM or timeout
- Timing comparisons are logged for benchmark tracking
  </verify>
  <done>
Performance test file exists and validates PathMatcher efficiency with 1000+ files. Caching is proven effective through relative timing comparisons. TEST-07 requirement is satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add edge case and stability tests</name>
  <files>__tests__/integration/path-matcher-performance.integration.test.ts</files>
  <action>
Extend the performance test file with edge cases:

1. **Third describe block: "Edge cases at scale"** with tests:

   a. Test "handles all files matching single pattern":
      - 1000 files all in src/auth/** (all thorough)
      - Should complete efficiently, result intensity = thorough

   b. Test "handles no files matching any pattern":
      - 1000 files in random/path{i}.xyz
      - Should complete efficiently, result intensity = default (standard)

   c. Test "handles duplicate file paths":
      - 500 unique paths, each duplicated (1000 total)
      - Caching should deduplicate, performance unchanged

   d. Test "handles deep nested paths":
      - Files with 10+ directory levels: a/b/c/d/e/f/g/h/i/j/file.ts
      - Glob patterns should still match efficiently

2. **Fourth describe block: "Stability under load"** with tests:

   a. Test "repeated calls do not leak memory":
      - Call determineIntensity() 100 times with 100 files each
      - Should complete without heap growth (indirect via no OOM)

   b. Test "different file sets on same matcher":
      - Create single PathMatcher instance
      - Call with fileSet1 (100 files), then fileSet2 (100 different files)
      - Both should complete, caching should not cause stale results

3. Add console.log statements for benchmark reporting:
   - Log duration for key tests
   - Log result.matchedPaths.length for verification
   - Format: `[BENCHMARK] testName: ${duration}ms, matched: ${count}`
  </action>
  <verify>
Run `npm test -- __tests__/integration/path-matcher-performance.integration.test.ts` and verify:
- All edge case tests pass
- Stability tests complete without errors
- Benchmark output is visible in test logs
  </verify>
  <done>
Complete performance test suite validates PathMatcher efficiency, caching, edge cases, and stability. Benchmark output provides metrics for tracking performance over time.
  </done>
</task>

</tasks>

<verification>
Run the full performance test suite:
```bash
npm test -- __tests__/integration/path-matcher-performance.integration.test.ts
```

Expected output includes:
- All tests pass
- Benchmark timing logs visible
- No memory warnings or timeouts

Verify TEST-07 requirement:
- "Performance test with 1000+ files validates PathMatcher caching efficiency"
</verification>

<success_criteria>
- `__tests__/integration/path-matcher-performance.integration.test.ts` exists with 10+ tests
- All tests pass when run with `npm test`
- 1000 file test completes in sub-second time
- 5000 file test completes without memory issues
- Caching efficiency is proven through relative timing comparisons
- Edge cases (all match, no match, duplicates, deep paths) are covered
- Benchmark timing is logged for future tracking
</success_criteria>

<output>
After completion, create `.planning/phases/09-integration-testing/09-02-SUMMARY.md`
</output>
