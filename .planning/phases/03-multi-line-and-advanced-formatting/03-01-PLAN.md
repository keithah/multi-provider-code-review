---
phase: 03-multi-line-and-advanced-formatting
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/utils/suggestion-validator.ts
  - __tests__/unit/utils/suggestion-validator.test.ts
autonomous: true

must_haves:
  truths:
    - "Line ranges with start > end are rejected"
    - "Ranges exceeding 50 lines are rejected"
    - "Ranges with gaps (non-consecutive lines) are rejected"
    - "Single-line ranges (start === end) are validated correctly"
    - "Valid consecutive ranges return position information"
  artifacts:
    - path: "src/utils/suggestion-validator.ts"
      provides: "validateSuggestionRange function for multi-line validation"
      exports: ["validateSuggestionRange", "RangeValidationResult"]
    - path: "__tests__/unit/utils/suggestion-validator.test.ts"
      provides: "Test coverage for range validation"
      min_lines: 80
  key_links:
    - from: "src/utils/suggestion-validator.ts"
      to: "src/utils/diff.ts"
      via: "import mapLinesToPositions"
      pattern: "import.*mapLinesToPositions.*from.*diff"
---

<objective>
TDD implementation of multi-line suggestion range validation.

Purpose: Validate that line ranges specified by LLMs are valid for GitHub multi-line suggestions (consecutive lines on RIGHT side of diff, within sanity limits).

Output: `validateSuggestionRange()` function with comprehensive test coverage, extending the existing suggestion-validator.ts module.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-CONTEXT.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-RESEARCH.md
@src/utils/suggestion-validator.ts
@src/utils/diff.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Multi-line range validation</name>
  <files>
    src/utils/suggestion-validator.ts
    __tests__/unit/utils/suggestion-validator.test.ts
  </files>
  <action>
TDD implementation of `validateSuggestionRange()` function.

**Interface to implement:**
```typescript
export interface RangeValidationResult {
  isValid: boolean;
  reason?: string;
  startPosition?: number;
  endPosition?: number;
}

export function validateSuggestionRange(
  startLine: number,
  endLine: number,
  patch: string | undefined
): RangeValidationResult
```

**RED phase - Write failing tests:**

Add a new describe block "validateSuggestionRange" to the existing test file with cases:

1. **Basic validation:**
   - Returns invalid for undefined patch
   - Returns invalid for empty patch
   - Returns invalid when start_line > end_line
   - Returns invalid for ranges > 50 lines

2. **Position validation:**
   - Returns invalid when start_line not in diff
   - Returns invalid when end_line not in diff
   - Returns valid with positions for valid range

3. **Consecutive validation:**
   - Returns invalid when intermediate line missing (gap)
   - Returns valid for consecutive lines in diff

4. **Single-line edge case:**
   - Returns valid for single-line range (start === end)
   - Single-line range has length 1 (not 0)

Use realistic patch data matching existing tests:
```typescript
const simplePatch = `@@ -1,3 +1,4 @@
 context line
+added line
 more context
+another added`;
```

**GREEN phase - Implement:**

Add to suggestion-validator.ts:
- Export `RangeValidationResult` interface
- Implement `validateSuggestionRange` that:
  1. Returns `{ isValid: false, reason: 'No patch available' }` for undefined/empty patch
  2. Returns `{ isValid: false, reason: 'Invalid range: start > end' }` if startLine > endLine
  3. Calculates span length as `endLine - startLine + 1` (inclusive)
  4. Returns `{ isValid: false, reason: 'Range too long: N lines (max 50)' }` if span > 50
  5. Uses `mapLinesToPositions(patch)` to get position map
  6. Checks all lines in range [startLine, endLine] exist in map (consecutive check)
  7. Returns positions if valid: `{ isValid: true, startPosition, endPosition }`

**Important:** Use inclusive range formula `endLine - startLine + 1` for length calculation. Do NOT forget the +1.

Note: Hunk boundary checking is deferred to Plan 03-02. This plan validates basics only.
  </action>
  <verify>
Run tests: `npm test -- --testPathPattern="suggestion-validator" --verbose`
All existing tests pass, new validateSuggestionRange tests pass.
  </verify>
  <done>
validateSuggestionRange validates: range direction, 50-line limit, all lines exist in diff (consecutive), returns positions on success.
  </done>
</task>

</tasks>

<verification>
- [ ] `npm test` passes (all tests including new ones)
- [ ] `npm run build` succeeds
- [ ] New tests cover: invalid patch, invalid range direction, range too long, gaps in range, valid ranges
- [ ] Existing validateSuggestionLine tests still pass
</verification>

<success_criteria>
- validateSuggestionRange function exists and is exported
- RangeValidationResult interface is exported
- All edge cases covered by tests
- Off-by-one errors avoided (range [10,10] has length 1)
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-line-and-advanced-formatting/03-01-SUMMARY.md`
</output>
