---
phase: 03-multi-line-and-advanced-formatting
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/utils/diff.ts
  - __tests__/unit/utils/diff.test.ts
autonomous: true

must_haves:
  truths:
    - "Ranges within a single hunk are detected as valid"
    - "Ranges crossing non-contiguous hunks are rejected"
    - "Edge case: range at exact hunk boundary is handled correctly"
    - "Files with multiple hunks are parsed correctly"
  artifacts:
    - path: "src/utils/diff.ts"
      provides: "isRangeWithinSingleHunk function for hunk boundary detection"
      exports: ["isRangeWithinSingleHunk"]
    - path: "__tests__/unit/utils/diff.test.ts"
      provides: "Test coverage for hunk boundary detection"
      min_lines: 50
  key_links:
    - from: "src/utils/diff.ts"
      to: "mapLinesToPositions"
      via: "uses same hunk parsing logic"
      pattern: "hunkRegex.*@@"
---

<objective>
TDD implementation of hunk boundary detection for multi-line suggestions.

Purpose: Validate that multi-line suggestion ranges don't cross non-contiguous hunk boundaries, which would cause GitHub API errors.

Output: `isRangeWithinSingleHunk()` function with comprehensive test coverage, added to existing diff.ts module.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-CONTEXT.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-RESEARCH.md
@src/utils/diff.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Hunk boundary detection</name>
  <files>
    src/utils/diff.ts
    __tests__/unit/utils/diff.test.ts
  </files>
  <action>
TDD implementation of `isRangeWithinSingleHunk()` function.

**Interface to implement:**
```typescript
/**
 * Check if a line range is within a single contiguous hunk.
 * Returns false if range crosses non-contiguous hunk boundaries.
 *
 * @param startLine - First line of range (inclusive)
 * @param endLine - Last line of range (inclusive)
 * @param patch - Unified diff patch string
 * @returns true if range is within single hunk, false otherwise
 */
export function isRangeWithinSingleHunk(
  startLine: number,
  endLine: number,
  patch: string | undefined
): boolean
```

**RED phase - Write failing tests:**

Add a new describe block "isRangeWithinSingleHunk" to diff.test.ts with cases:

1. **Single hunk:**
```typescript
const singleHunkPatch = `@@ -1,3 +1,5 @@
 context
+line 2
+line 3
+line 4
 more context`;
```
   - Range within single hunk returns true (e.g., lines 2-4)
   - Range at start of hunk returns true (e.g., lines 1-2)
   - Range at end of hunk returns true (e.g., lines 4-5)

2. **Multiple non-contiguous hunks:**
```typescript
const multiHunkPatch = `@@ -1,3 +1,4 @@
 context
+added at line 2
 more context
 line 4
@@ -10,3 +11,4 @@
 distant context
+added at line 12
 more distant`;
```
   - Range within first hunk returns true (lines 1-4)
   - Range within second hunk returns true (lines 11-13)
   - Range crossing hunks returns false (lines 4-12)

3. **Edge cases:**
   - Returns false for undefined patch
   - Returns false for empty patch
   - Single-line range (start === end) in hunk returns true
   - Range where lines exist but span different hunks returns false

**GREEN phase - Implement:**

Add to diff.ts:

```typescript
export function isRangeWithinSingleHunk(
  startLine: number,
  endLine: number,
  patch: string | undefined
): boolean {
  if (!patch) return false;

  const lines = patch.split('\n');
  const hunkRegex = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/;
  const noNewlineMarker = '\\ No newline at end of file';

  let currentNew = 0;
  let foundStart = false;
  let inActiveHunk = false;

  for (const raw of lines) {
    if (raw === noNewlineMarker) continue;

    const hunkMatch = raw.match(hunkRegex);

    if (hunkMatch) {
      // New hunk starting
      if (foundStart) {
        // We found start but hit a new hunk before finding end
        // This means range crosses hunk boundary
        return false;
      }
      currentNew = parseInt(hunkMatch[2], 10);
      inActiveHunk = true;
      continue;
    }

    if (!inActiveHunk) continue;

    // Track RIGHT side lines (added or context, not deleted)
    if (raw.startsWith('+') || (!raw.startsWith('-') && raw.length > 0)) {
      if (currentNew === startLine) {
        foundStart = true;
      }
      if (currentNew === endLine) {
        // Found end - only valid if we found start in same hunk
        return foundStart;
      }
      currentNew += 1;
    }
    // Deleted lines don't advance currentNew (LEFT side only)
  }

  // Never found complete range
  return false;
}
```

Key logic:
- Track when we enter each hunk (hunk header resets state)
- If we find startLine and then hit another hunk header before endLine, return false
- Only return true when we find both start and end within same hunk traversal
  </action>
  <verify>
Run tests: `npm test -- --testPathPattern="diff" --verbose`
All existing diff tests pass, new isRangeWithinSingleHunk tests pass.
  </verify>
  <done>
isRangeWithinSingleHunk detects whether a line range is contained within a single contiguous hunk, rejecting ranges that cross hunk boundaries.
  </done>
</task>

</tasks>

<verification>
- [ ] `npm test` passes (all tests including new ones)
- [ ] `npm run build` succeeds
- [ ] New tests cover: single hunk, multiple hunks, crossing hunks, edge cases
- [ ] Existing diff.ts tests still pass (mapLinesToPositions, mapAddedLines, etc.)
</verification>

<success_criteria>
- isRangeWithinSingleHunk function exists and is exported
- Handles both single and multiple hunk patches
- Correctly rejects ranges that cross hunk boundaries
- Handles edge cases (undefined patch, single-line range)
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-line-and-advanced-formatting/03-02-SUMMARY.md`
</output>
