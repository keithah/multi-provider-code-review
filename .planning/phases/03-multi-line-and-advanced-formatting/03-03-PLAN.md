---
phase: 03-multi-line-and-advanced-formatting
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/utils/suggestion-validator.ts
  - src/github/comment-poster.ts
  - __tests__/unit/utils/suggestion-validator.test.ts
autonomous: true

must_haves:
  truths:
    - "validateSuggestionRange includes hunk boundary check"
    - "Deletion-only files are filtered from suggestion generation"
    - "Multi-line suggestions use start_line parameter in GitHub API"
    - "Comments are sorted by file path then line number for batch commit UX"
    - "Multi-line suggestions with embedded backticks are escaped correctly (FR-3.3)"
  artifacts:
    - path: "src/utils/suggestion-validator.ts"
      provides: "Complete range validation with hunk boundary checking"
      exports: ["validateSuggestionRange", "isDeletionOnlyFile"]
    - path: "src/github/comment-poster.ts"
      provides: "Multi-line suggestion support with start_line API parameter"
      contains: "start_line"
  key_links:
    - from: "src/utils/suggestion-validator.ts"
      to: "src/utils/diff.ts"
      via: "import isRangeWithinSingleHunk"
      pattern: "import.*isRangeWithinSingleHunk.*from.*diff"
    - from: "src/github/comment-poster.ts"
      to: "src/utils/suggestion-validator.ts"
      via: "import validateSuggestionRange"
      pattern: "import.*validateSuggestionRange.*from.*suggestion-validator"
---

<objective>
Integrate multi-line validation and add GitHub API multi-line support.

Purpose: Wire up the validation utilities from plans 03-01 and 03-02 into the comment posting pipeline, enabling multi-line suggestions with proper GitHub API parameters.

Output: Complete multi-line suggestion support with hunk boundary validation, deletion-only file filtering, and batch commit ordering.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-CONTEXT.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-RESEARCH.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-01-SUMMARY.md
@.planning/phases/03-multi-line-and-advanced-formatting/03-02-SUMMARY.md
@src/utils/suggestion-validator.ts
@src/utils/diff.ts
@src/github/comment-poster.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate hunk boundary check into validateSuggestionRange</name>
  <files>
    src/utils/suggestion-validator.ts
    __tests__/unit/utils/suggestion-validator.test.ts
  </files>
  <action>
Update validateSuggestionRange to include hunk boundary validation.

**Changes to suggestion-validator.ts:**

1. Add import at top:
```typescript
import { mapLinesToPositions, isRangeWithinSingleHunk } from './diff';
```

2. Add hunk boundary check to validateSuggestionRange AFTER the consecutive lines check:
```typescript
// Check 5: Range doesn't cross hunk boundaries
if (!isRangeWithinSingleHunk(startLine, endLine, patch)) {
  return { isValid: false, reason: 'Range crosses hunk boundary' };
}
```

**Add tests to suggestion-validator.test.ts:**

Add a new describe block inside "validateSuggestionRange" for hunk boundary cases:

```typescript
describe('hunk boundary validation', () => {
  const multiHunkPatch = `@@ -1,3 +1,4 @@
 context
+line 2
 more context
 line 4
@@ -10,3 +11,4 @@
 distant context
+line 12
 more distant`;

  it('returns valid for range within single hunk', () => {
    const result = validateSuggestionRange(1, 4, multiHunkPatch);
    expect(result.isValid).toBe(true);
  });

  it('returns invalid for range crossing hunks', () => {
    const result = validateSuggestionRange(2, 12, multiHunkPatch);
    expect(result.isValid).toBe(false);
    expect(result.reason).toBe('Range crosses hunk boundary');
  });
});
```
  </action>
  <verify>
Run tests: `npm test -- --testPathPattern="suggestion-validator" --verbose`
All tests pass including new hunk boundary tests.
  </verify>
  <done>
validateSuggestionRange now includes hunk boundary validation using isRangeWithinSingleHunk.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deletion-only file filtering utility</name>
  <files>
    src/utils/suggestion-validator.ts
    __tests__/unit/utils/suggestion-validator.test.ts
  </files>
  <action>
Add utilities for filtering deletion-only files where suggestions are impossible.

**Add to suggestion-validator.ts:**

```typescript
import { FileChange } from '../types';

/**
 * Check if file is deletion-only (no suggestions possible).
 * GitHub suggestions require RIGHT side lines, which don't exist
 * in deletion-only files.
 *
 * @param file - FileChange object with status and additions count
 * @returns true if file has no added lines (suggestions impossible)
 */
export function isDeletionOnlyFile(file: { status?: string; additions?: number }): boolean {
  return file.status === 'removed' || (file.additions ?? 0) === 0;
}
```

Note: Use a minimal interface `{ status?: string; additions?: number }` instead of importing full FileChange type to keep the utility flexible.

**Add tests to suggestion-validator.test.ts:**

```typescript
describe('isDeletionOnlyFile', () => {
  it('returns true for removed files', () => {
    expect(isDeletionOnlyFile({ status: 'removed', additions: 0 })).toBe(true);
  });

  it('returns true for files with zero additions', () => {
    expect(isDeletionOnlyFile({ status: 'modified', additions: 0 })).toBe(true);
  });

  it('returns false for files with additions', () => {
    expect(isDeletionOnlyFile({ status: 'modified', additions: 5 })).toBe(false);
  });

  it('returns true when additions is undefined (treated as 0)', () => {
    expect(isDeletionOnlyFile({ status: 'modified' })).toBe(true);
  });

  it('returns false for added files with additions', () => {
    expect(isDeletionOnlyFile({ status: 'added', additions: 10 })).toBe(false);
  });
});
```
  </action>
  <verify>
Run tests: `npm test -- --testPathPattern="suggestion-validator" --verbose`
All tests pass including new isDeletionOnlyFile tests.
  </verify>
  <done>
isDeletionOnlyFile utility detects files where suggestions are impossible due to no RIGHT-side lines.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add multi-line validation and deletion filtering to CommentPoster</name>
  <files>
    src/github/comment-poster.ts
  </files>
  <action>
Update CommentPoster.postInline() to validate multi-line ranges and filter deletion-only files.

**Changes to comment-poster.ts:**

1. Add imports:
```typescript
import { validateSuggestionRange, isDeletionOnlyFile } from '../utils/suggestion-validator';
```

2. Before filtering to apiComments, filter out deletion-only files from files list for suggestion validation purposes:
```typescript
// Filter out deletion-only files (no suggestions possible)
const filesWithAdditions = files.filter(f => !isDeletionOnlyFile(f));
const filesWithAdditionsSet = new Set(filesWithAdditions.map(f => f.filename));
```

3. In the apiComments mapping, update suggestion validation to handle multi-line:

```typescript
// Validate suggestions can be applied at this line/range
if (c.body.includes('```suggestion')) {
  const file = files.find(f => f.filename === c.path);

  // Skip suggestions for deletion-only files
  if (!filesWithAdditionsSet.has(c.path)) {
    logger.debug(`Skipping suggestion for deletion-only file: ${c.path}`);
    c.body = c.body.replace(/```suggestion[\s\S]*?```/g, '_Suggestion not available (file has no additions)_');
  } else if (file?.patch) {
    // Check if this is a multi-line suggestion (has start_line)
    const startLine = (c as any).start_line;
    if (startLine !== undefined && startLine !== c.line) {
      // Multi-line suggestion - validate range
      const validation = validateSuggestionRange(startLine, c.line, file.patch);
      if (!validation.isValid) {
        logger.debug(`Multi-line suggestion invalid at ${c.path}:${startLine}-${c.line}: ${validation.reason}`);
        c.body = c.body.replace(/```suggestion[\s\S]*?```/g, `_Suggestion not available: ${validation.reason}_`);
      }
    } else {
      // Single-line suggestion - use existing validation
      if (!isSuggestionLineValid(c.line, file.patch)) {
        logger.debug(`Suggestion line ${c.path}:${c.line} not valid in diff, posting without suggestion block`);
        c.body = c.body.replace(/```suggestion[\s\S]*?```/g, '_Suggestion not available for this line_');
      }
    }
  }
}
```

**Important:** Change logger.warn to logger.debug for suggestion validation failures (per Phase 2 decision - these are normal flow, not exceptional).
  </action>
  <verify>
- Run: `npm run build` - should compile without errors
- Run: `npm test` - all tests should pass
- Verify no TypeScript errors in comment-poster.ts
  </verify>
  <done>
CommentPoster validates multi-line suggestion ranges and filters deletion-only files with graceful degradation.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add start_line API support and batch commit sorting</name>
  <files>
    src/github/comment-poster.ts
  </files>
  <action>
Complete multi-line GitHub API integration with start_line parameter and batch commit ordering.

**Changes to comment-poster.ts:**

1. Update the API comment object creation to include start_line when present:

```typescript
const apiComment: any = { path: c.path, position, body: c.body };
const startLine = (c as any).start_line;
if (startLine !== undefined && startLine !== c.line) {
  // Multi-line: use line-based parameters instead of position
  apiComment.start_line = startLine;
  apiComment.line = c.line;
  apiComment.start_side = 'RIGHT';
  apiComment.side = 'RIGHT';
  delete apiComment.position; // Can't use both position and line
}
return apiComment;
```

2. Sort comments by file path and line number for optimal batch commit UX (add before the filter):

```typescript
// Sort comments for optimal batch commit UX (top-to-bottom per file)
const sortedComments = [...comments].sort((a, b) => {
  const pathCompare = a.path.localeCompare(b.path);
  if (pathCompare !== 0) return pathCompare;
  return a.line - b.line;
});
```

Then use sortedComments instead of comments in the enhancedComments mapping.

**FR-3.3 Verification (Multi-Line Escaping):**

Phase 1's `formatSuggestionBlock` in `src/utils/suggestion-formatter.ts` already handles multi-line escaping correctly because:
- `countMaxConsecutiveBackticks()` scans the entire content string (all lines)
- Fence delimiter is calculated from max backticks across all lines
- Existing tests verify: multi-line content (line 69-73), mixed backtick sequences across lines (line 75-80)

To verify FR-3.3 compliance, run the existing formatter tests:
```bash
npm test -- --testPathPattern="suggestion-formatter" --verbose
```

Confirm tests pass for:
- `handles multi-line content`
- `handles content with mixed backtick sequences`

These tests prove FR-3.3 is satisfied by Phase 1 implementation.
  </action>
  <verify>
- Run: `npm run build` - should compile without errors
- Run: `npm test` - all tests should pass
- Run: `npm test -- --testPathPattern="suggestion-formatter" --verbose` - verify FR-3.3 multi-line escaping tests pass
- Verify start_line logic is wired in comment-poster.ts
  </verify>
  <done>
CommentPoster supports multi-line suggestions with start_line API parameter and sorts comments for batch commit UX. FR-3.3 (multi-line escaping) verified via existing Phase 1 tests.
  </done>
</task>

</tasks>

<verification>
- [ ] `npm test` passes (all tests)
- [ ] `npm run build` succeeds
- [ ] validateSuggestionRange includes hunk boundary check
- [ ] isDeletionOnlyFile exported and tested
- [ ] CommentPoster handles multi-line suggestions with start_line parameter
- [ ] Comments sorted by file path and line for batch commit
- [ ] Deletion-only files filtered from suggestion generation
- [ ] FR-3.3 verified: `npm test -- --testPathPattern="suggestion-formatter"` passes (multi-line escaping)
</verification>

<success_criteria>
- Multi-line suggestions validated: range direction, 50-line limit, consecutive, hunk boundaries
- Deletion-only files detected and suggestions skipped gracefully
- GitHub API comments include start_line for multi-line ranges
- Batch commit UX optimized via sorting
- FR-3.3 satisfied: multi-line suggestions with embedded backticks are escaped correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-line-and-advanced-formatting/03-03-SUMMARY.md`
</output>
