---
phase: 02-llm-fix-generation-integration
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/analysis/llm/parser.ts
  - __tests__/unit/analysis/llm/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "Parser extracts suggestion field from Finding objects"
    - "Invalid suggestions are filtered out with warning log"
    - "Valid suggestions are preserved in Finding.suggestion"
    - "Findings without suggestions still flow through normally"
  artifacts:
    - path: "src/analysis/llm/parser.ts"
      provides: "Suggestion extraction and validation"
      contains: "validateSuggestionSanity"
    - path: "__tests__/unit/analysis/llm/parser.test.ts"
      provides: "Test coverage for suggestion extraction"
      contains: "suggestion"
  key_links:
    - from: "src/analysis/llm/parser.ts"
      to: "src/utils/suggestion-sanity.ts"
      via: "import validateSuggestionSanity"
      pattern: "import.*suggestion-sanity"
    - from: "src/analysis/llm/parser.ts"
      to: "Finding.suggestion"
      via: "field assignment"
      pattern: "suggestion.*validated"
---

<objective>
Integrate suggestion validation into the LLM parser to extract and validate suggestion fields

Purpose: Wire the sanity validation into the parsing pipeline so suggestions flow from LLM responses through to Finding objects, with invalid suggestions filtered out gracefully.

Output: Updated parser.ts that extracts suggestion field from provider results, validates with sanity checks, and preserves valid suggestions in Finding objects.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-llm-fix-generation-integration/02-CONTEXT.md
@.planning/phases/02-llm-fix-generation-integration/02-01-SUMMARY.md
@.planning/phases/02-llm-fix-generation-integration/02-02-SUMMARY.md
@src/analysis/llm/parser.ts
@src/types/index.ts
@src/utils/suggestion-sanity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update parser to extract and validate suggestions</name>
  <files>src/analysis/llm/parser.ts</files>
  <action>
Update the `extractFindings` function to validate and preserve suggestion fields:

1. Add imports at top:
```typescript
import { validateSuggestionSanity } from '../../utils/suggestion-sanity';
import { logger } from '../../utils/logger';
```

2. Update the function to validate suggestions before adding to Finding:

```typescript
export function extractFindings(results: ProviderResult[]): Finding[] {
  const findings: Finding[] = [];

  for (const result of results) {
    if (result.status !== 'success' || !result.result?.findings) continue;

    for (const finding of result.result.findings) {
      // Validate suggestion if present
      let suggestion: string | undefined = undefined;
      if (finding.suggestion !== undefined && finding.suggestion !== null) {
        const validation = validateSuggestionSanity(finding.suggestion);
        if (validation.isValid) {
          suggestion = validation.suggestion;
        } else {
          logger.debug(
            `Skipping invalid suggestion for ${finding.file}:${finding.line}: ${validation.reason}`
          );
        }
      }

      findings.push({
        ...finding,
        suggestion,  // Use validated suggestion (or undefined)
        provider: result.name,
        providers: finding.providers || [result.name],
      });
    }
  }

  return findings;
}
```

Key points:
- Use logger.debug (not warn) per CONTEXT.md "Claude's Discretion" for logging approach
- Preserve all other finding fields via spread operator
- Explicit undefined assignment ensures invalid suggestions don't leak through
- No retries on invalid suggestions per CONTEXT.md decisions
  </action>
  <verify>
- `npm run build` succeeds
- `grep -n "validateSuggestionSanity" src/analysis/llm/parser.ts` shows import and usage
  </verify>
  <done>
Parser extracts suggestion field from provider results, validates with sanity checks, and preserves valid suggestions in Finding objects while filtering invalid ones with debug logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for suggestion extraction</name>
  <files>__tests__/unit/analysis/llm/parser.test.ts</files>
  <action>
Check if test file exists. If not, create it with proper structure.

Add test cases for suggestion extraction:

```typescript
import { extractFindings } from '../../../../src/analysis/llm/parser';
import { ProviderResult } from '../../../../src/types';

describe('extractFindings', () => {
  const createProviderResult = (findings: any[]): ProviderResult => ({
    name: 'test-provider',
    status: 'success',
    result: { content: '', findings },
    durationSeconds: 1,
  });

  it('extracts valid suggestion from finding', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: 'const x = 1;',
    }])];

    const findings = extractFindings(results);

    expect(findings).toHaveLength(1);
    expect(findings[0].suggestion).toBe('const x = 1;');
  });

  it('filters out invalid suggestion (no code syntax)', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: 'You should fix this issue',
    }])];

    const findings = extractFindings(results);

    expect(findings).toHaveLength(1);
    expect(findings[0].suggestion).toBeUndefined();
  });

  it('preserves finding without suggestion', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
    }])];

    const findings = extractFindings(results);

    expect(findings).toHaveLength(1);
    expect(findings[0].suggestion).toBeUndefined();
    expect(findings[0].file).toBe('test.ts');
  });

  it('trims valid suggestion', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: '  const x = 1;  ',
    }])];

    const findings = extractFindings(results);

    expect(findings[0].suggestion).toBe('const x = 1;');
  });

  it('handles empty suggestion string', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: '',
    }])];

    const findings = extractFindings(results);

    expect(findings[0].suggestion).toBeUndefined();
  });
});
```

Follow existing test patterns in the codebase. Ensure test file is in correct location.
  </action>
  <verify>
- `npm test -- --testPathPattern=parser` passes
- All suggestion extraction tests pass
  </verify>
  <done>
Tests verify suggestion extraction, validation filtering, preservation of findings without suggestions, trimming, and edge cases.
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
npm test
npm run build
```

Manual verification of end-to-end flow:
```bash
grep -rn "suggestion" src/analysis/llm/parser.ts
```
</verification>

<success_criteria>
1. Parser imports and uses validateSuggestionSanity
2. Valid suggestions are preserved in Finding objects
3. Invalid suggestions are filtered with debug logging
4. Findings without suggestions flow through unchanged
5. All tests pass
6. Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-llm-fix-generation-integration/02-03-SUMMARY.md`
</output>
