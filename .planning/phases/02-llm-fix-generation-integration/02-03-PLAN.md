---
phase: 02-llm-fix-generation-integration
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/analysis/llm/parser.ts
  - __tests__/unit/analysis/llm/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "Parser extracts suggestion field from Finding objects"
    - "Invalid suggestions are filtered out with warning log"
    - "Valid suggestions are preserved in Finding.suggestion"
    - "Findings without suggestions still flow through normally"
    - "Phase 1 formatters handle undefined suggestions gracefully (no crash, finding still posted)"
  artifacts:
    - path: "src/analysis/llm/parser.ts"
      provides: "Suggestion extraction and validation"
      contains: "validateSuggestionSanity"
    - path: "__tests__/unit/analysis/llm/parser.test.ts"
      provides: "Test coverage for suggestion extraction"
      contains: "suggestion"
  key_links:
    - from: "src/analysis/llm/parser.ts"
      to: "src/utils/suggestion-sanity.ts"
      via: "import validateSuggestionSanity"
      pattern: "import.*suggestion-sanity"
    - from: "src/analysis/llm/parser.ts"
      to: "Finding.suggestion"
      via: "field assignment"
      pattern: "suggestion.*validated"
    - from: "Finding.suggestion (undefined)"
      to: "src/output/formatter.ts"
      via: "graceful handling"
      pattern: "if \\(f\\.suggestion\\)"
---

<objective>
Integrate suggestion validation into the LLM parser to extract and validate suggestion fields

Purpose: Wire the sanity validation into the parsing pipeline so suggestions flow from LLM responses through to Finding objects, with invalid suggestions filtered out gracefully.

Output: Updated parser.ts that extracts suggestion field from provider results, validates with sanity checks, and preserves valid suggestions in Finding objects.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-llm-fix-generation-integration/02-CONTEXT.md
@.planning/phases/02-llm-fix-generation-integration/02-01-SUMMARY.md
@.planning/phases/02-llm-fix-generation-integration/02-02-SUMMARY.md
@src/analysis/llm/parser.ts
@src/types/index.ts
@src/utils/suggestion-sanity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update parser to extract and validate suggestions</name>
  <files>src/analysis/llm/parser.ts</files>
  <action>
Update the `extractFindings` function to validate and preserve suggestion fields:

1. Add imports at top:
```typescript
import { validateSuggestionSanity } from '../../utils/suggestion-sanity';
import { logger } from '../../utils/logger';
```

2. Update the function to validate suggestions before adding to Finding:

```typescript
export function extractFindings(results: ProviderResult[]): Finding[] {
  const findings: Finding[] = [];

  for (const result of results) {
    if (result.status !== 'success' || !result.result?.findings) continue;

    for (const finding of result.result.findings) {
      // Validate suggestion if present
      // Note: finding.suggestion comes directly from JSON.parse of the LLM response.
      // Provider wrappers return parsed JSON, so the suggestion field (if any) is
      // already on the raw finding object. We just need to validate it.
      let suggestion: string | undefined = undefined;
      if (finding.suggestion !== undefined && finding.suggestion !== null) {
        const validation = validateSuggestionSanity(finding.suggestion);
        if (validation.isValid) {
          suggestion = validation.suggestion;
        } else {
          logger.debug(
            `Skipping invalid suggestion for ${finding.file}:${finding.line}: ${validation.reason}`
          );
        }
      }

      findings.push({
        ...finding,
        suggestion,  // Use validated suggestion (or undefined)
        provider: result.name,
        providers: finding.providers || [result.name],
      });
    }
  }

  return findings;
}
```

Key points:
- Use logger.debug (not warn) per CONTEXT.md "Claude's Discretion" for logging approach
- Preserve all other finding fields via spread operator
- Explicit undefined assignment ensures invalid suggestions don't leak through
- No retries on invalid suggestions per CONTEXT.md decisions
- finding.suggestion is already parsed from LLM JSON by provider wrappers
  </action>
  <verify>
- `npm run build` succeeds
- `grep -n "validateSuggestionSanity" src/analysis/llm/parser.ts` shows import and usage
  </verify>
  <done>
Parser extracts suggestion field from provider results, validates with sanity checks, and preserves valid suggestions in Finding objects while filtering invalid ones with debug logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for suggestion extraction</name>
  <files>__tests__/unit/analysis/llm/parser.test.ts</files>
  <action>
Check if test file exists. If not, create it with proper structure.

Add test cases for suggestion extraction:

```typescript
import { extractFindings } from '../../../../src/analysis/llm/parser';
import { ProviderResult } from '../../../../src/types';

describe('extractFindings', () => {
  const createProviderResult = (findings: any[]): ProviderResult => ({
    name: 'test-provider',
    status: 'success',
    result: { content: '', findings },
    durationSeconds: 1,
  });

  it('extracts valid suggestion from finding', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: 'const x = 1;',
    }])];

    const findings = extractFindings(results);

    expect(findings).toHaveLength(1);
    expect(findings[0].suggestion).toBe('const x = 1;');
  });

  it('filters out invalid suggestion (no code syntax)', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: 'You should fix this issue',
    }])];

    const findings = extractFindings(results);

    expect(findings).toHaveLength(1);
    expect(findings[0].suggestion).toBeUndefined();
  });

  it('preserves finding without suggestion', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
    }])];

    const findings = extractFindings(results);

    expect(findings).toHaveLength(1);
    expect(findings[0].suggestion).toBeUndefined();
    expect(findings[0].file).toBe('test.ts');
  });

  it('trims valid suggestion', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: '  const x = 1;  ',
    }])];

    const findings = extractFindings(results);

    expect(findings[0].suggestion).toBe('const x = 1;');
  });

  it('handles empty suggestion string', () => {
    const results = [createProviderResult([{
      file: 'test.ts',
      line: 10,
      severity: 'major',
      title: 'Bug',
      message: 'Issue',
      suggestion: '',
    }])];

    const findings = extractFindings(results);

    expect(findings[0].suggestion).toBeUndefined();
  });
});
```

Follow existing test patterns in the codebase. Ensure test file is in correct location.
  </action>
  <verify>
- `npm test -- --testPathPattern=parser` passes
- All suggestion extraction tests pass
  </verify>
  <done>
Tests verify suggestion extraction, validation filtering, preservation of findings without suggestions, trimming, and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify graceful degradation in Phase 1 formatters</name>
  <files>__tests__/unit/analysis/llm/parser.test.ts</files>
  <action>
Add a verification test that confirms end-to-end graceful degradation when suggestion is undefined:

1. Add to the same test file (parser.test.ts) a new describe block that verifies the integration assumption:

```typescript
import { MarkdownFormatter } from '../../../../src/output/formatter';

describe('Graceful degradation integration', () => {
  it('formatter handles finding with undefined suggestion (does not crash, posts finding)', () => {
    // Simulate a finding that passed through parser with invalid/no suggestion
    const findingWithoutSuggestion = {
      file: 'test.ts',
      line: 10,
      severity: 'major' as const,
      title: 'Potential null reference',
      message: 'Variable may be null here',
      suggestion: undefined, // Invalid/missing suggestion filtered out
      provider: 'test-provider',
      providers: ['test-provider'],
    };

    const review = {
      summary: 'Test review',
      findings: [findingWithoutSuggestion],
      metrics: {
        durationSeconds: 1,
        totalCost: 0,
        totalTokens: 0,
        providersUsed: 1,
        providersSuccess: 1,
        providersFailed: 0,
      },
    };

    const formatter = new MarkdownFormatter();
    const output = formatter.format(review);

    // Finding should still be in output (graceful degradation: finding posted without suggestion)
    expect(output).toContain('test.ts:10');
    expect(output).toContain('Potential null reference');
    expect(output).toContain('Variable may be null here');
    // Should NOT contain suggestion block
    expect(output).not.toContain('```suggestion');
    expect(output).not.toContain('Suggested fix:');
  });

  it('formatter handles finding with valid suggestion', () => {
    const findingWithSuggestion = {
      file: 'test.ts',
      line: 10,
      severity: 'major' as const,
      title: 'Use const',
      message: 'Prefer const over let',
      suggestion: 'const x = 1;',
      provider: 'test-provider',
      providers: ['test-provider'],
    };

    const review = {
      summary: 'Test review',
      findings: [findingWithSuggestion],
      metrics: {
        durationSeconds: 1,
        totalCost: 0,
        totalTokens: 0,
        providersUsed: 1,
        providersSuccess: 1,
        providersFailed: 0,
      },
    };

    const formatter = new MarkdownFormatter();
    const output = formatter.format(review);

    // Finding should have suggestion block
    expect(output).toContain('test.ts:10');
    expect(output).toContain('Use const');
    expect(output).toContain('```suggestion');
    expect(output).toContain('const x = 1;');
  });
});
```

This explicitly tests FR-2.3: "posts finding without suggestion block" and "does NOT suppress the finding" when suggestion is undefined.
  </action>
  <verify>
- `npm test -- --testPathPattern=parser` passes
- Graceful degradation tests pass (finding posted without suggestion, no crash)
  </verify>
  <done>
Tests confirm that formatters from Phase 1 handle undefined suggestions gracefully: finding is still posted, no suggestion block included, no crash.
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
npm test
npm run build
```

Manual verification of end-to-end flow:
```bash
grep -rn "suggestion" src/analysis/llm/parser.ts
```

Verify graceful degradation:
```bash
npm test -- --testPathPattern=parser --testNamePattern="graceful"
```
</verification>

<success_criteria>
1. Parser imports and uses validateSuggestionSanity
2. Valid suggestions are preserved in Finding objects
3. Invalid suggestions are filtered with debug logging
4. Findings without suggestions flow through unchanged
5. Formatters handle undefined suggestions gracefully (test proves it)
6. All tests pass
7. Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-llm-fix-generation-integration/02-03-SUMMARY.md`
</output>
