---
phase: 04-validation-and-quality
plan: 05
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - src/config/schema.ts
  - src/types/index.ts
  - src/analysis/consensus.ts
  - __tests__/analysis/consensus.test.ts
autonomous: true

must_haves:
  truths:
    - "Config schema accepts quality threshold settings"
    - "ConsensusEngine uses AST comparison for suggestion agreement"
    - "Critical severity findings require consensus when configured"
    - "ConsensusEngine.filter sets hasConsensus on merged findings"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "Quality config schema fields"
      contains: "min_confidence"
    - path: "src/analysis/consensus.ts"
      provides: "AST-based consensus for suggestions"
      contains: "areASTsEquivalent"
    - path: "src/types/index.ts"
      provides: "Finding type with hasConsensus"
      contains: "hasConsensus"
  key_links:
    - from: "src/analysis/consensus.ts"
      to: "src/validation/ast-comparator.ts"
      via: "import areASTsEquivalent"
      pattern: "areASTsEquivalent"
---

<objective>
Extend config schema with quality settings and integrate AST comparison into consensus engine.

Purpose: Enable configurable quality thresholds (min_confidence, per-severity) and upgrade consensus detection to use AST-based equivalence for suggestions (not just string matching). The ConsensusEngine.filter method will SET hasConsensus on merged findings when multiple providers agree on a suggestion.

Output: Updated config schema and consensus engine with AST-based suggestion comparison that sets hasConsensus during aggregation.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@src/config/schema.ts
@src/types/index.ts
@src/analysis/consensus.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config schema with quality settings</name>
  <files>src/config/schema.ts, src/types/index.ts</files>
  <action>
    Add quality configuration fields to ReviewConfigSchema (zod):

    ```typescript
    // In schema.ts, add to ReviewConfigSchema:
    min_confidence: z.number().min(0).max(1).optional(),  // Default 0.7
    confidence_threshold: z.object({
      critical: z.number().min(0).max(1).optional(),
      high: z.number().min(0).max(1).optional(),
      medium: z.number().min(0).max(1).optional(),
      low: z.number().min(0).max(1).optional(),
    }).optional(),
    consensus_required_for_critical: z.boolean().optional(),  // Default true
    consensus_min_agreement: z.number().int().min(2).optional(),  // Default 2
    suggestion_syntax_validation: z.boolean().optional(),  // Default true
    ```

    Add corresponding fields to ReviewConfig interface in types/index.ts:
    ```typescript
    minConfidence?: number;
    confidenceThreshold?: {
      critical?: number;
      high?: number;
      medium?: number;
      low?: number;
    };
    consensusRequiredForCritical?: boolean;
    consensusMinAgreement?: number;
    suggestionSyntaxValidation?: boolean;
    ```

    Also add `hasConsensus` field to Finding interface (Plan 06 depends on this):
    ```typescript
    export interface Finding {
      // ... existing fields ...
      hasConsensus?: boolean;  // Set during aggregation when multiple providers agree
    }
    ```

    Do NOT change field naming convention - follow existing snake_case for schema, camelCase for interface.
  </action>
  <verify>
    ```bash
    npm run typecheck
    ```
    No TypeScript errors.
  </verify>
  <done>Config schema accepts quality settings, types updated to match, Finding has hasConsensus field.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate AST comparison into consensus engine</name>
  <files>src/analysis/consensus.ts</files>
  <action>
    Modify ConsensusEngine to detect suggestion agreement using AST comparison:

    1. Add import: `import { areASTsEquivalent } from '../validation/ast-comparator';`
    2. Add import: `import { detectLanguage } from './ast/parsers';`

    3. Add new interface for suggestion consensus:
    ```typescript
    export interface SuggestionConsensus {
      hasSuggestionConsensus: boolean;
      agreementCount: number;
      suggestions: string[];
    }
    ```

    4. Add new method to ConsensusEngine:
    ```typescript
    /**
     * Check if multiple providers' suggestions are AST-equivalent.
     * Used for critical severity findings where consensus is required.
     */
    checkSuggestionConsensus(
      suggestions: Array<{ provider: string; suggestion: string; file: string }>,
      minAgreement: number = 2
    ): SuggestionConsensus {
      if (suggestions.length < minAgreement) {
        return { hasSuggestionConsensus: false, agreementCount: 0, suggestions: [] };
      }

      const language = detectLanguage(suggestions[0].file);
      if (language === 'unknown') {
        // Can't compare ASTs for unknown language, fall back to string comparison
        return this.checkStringConsensus(suggestions, minAgreement);
      }

      // Group by AST equivalence
      const groups: string[][] = [];
      for (const s of suggestions) {
        let added = false;
        for (const group of groups) {
          const result = areASTsEquivalent(group[0], s.suggestion, language);
          if (result.equivalent) {
            group.push(s.suggestion);
            added = true;
            break;
          }
        }
        if (!added) {
          groups.push([s.suggestion]);
        }
      }

      // Find largest group
      const largestGroup = groups.reduce((a, b) => a.length > b.length ? a : b, []);

      return {
        hasSuggestionConsensus: largestGroup.length >= minAgreement,
        agreementCount: largestGroup.length,
        suggestions: largestGroup
      };
    }

    private checkStringConsensus(
      suggestions: Array<{ provider: string; suggestion: string }>,
      minAgreement: number
    ): SuggestionConsensus {
      // Fallback: exact string match (normalized whitespace)
      const normalized = suggestions.map(s => ({ ...s, normalized: s.suggestion.trim().replace(/\s+/g, ' ') }));
      const counts = new Map<string, string[]>();
      for (const s of normalized) {
        const arr = counts.get(s.normalized) || [];
        arr.push(s.suggestion);
        counts.set(s.normalized, arr);
      }
      const largest = Array.from(counts.values()).reduce((a, b) => a.length > b.length ? a : b, []);
      return {
        hasSuggestionConsensus: largest.length >= minAgreement,
        agreementCount: largest.length,
        suggestions: largest
      };
    }
    ```

    5. Export SuggestionConsensus from module.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="consensus" --verbose
    ```
    TypeScript compiles, existing consensus tests pass (new method doesn't break existing behavior).
  </verify>
  <done>ConsensusEngine.checkSuggestionConsensus uses AST comparison for language-aware equivalence detection.</done>
</task>

<task type="auto">
  <name>Task 3: Wire consensus checking into filter method to set hasConsensus</name>
  <files>src/analysis/consensus.ts</files>
  <action>
    Modify the existing `filter` method in ConsensusEngine to SET `hasConsensus` on merged findings:

    The existing filter method groups findings by key and merges them. When merging findings that have suggestions from multiple providers, call checkSuggestionConsensus and set the result on the merged finding.

    In the filter method, after merging findings (around the `grouped.set(key, {...})` logic):

    ```typescript
    filter(findings: Finding[]): Finding[] {
      const grouped = new Map<string, Finding & { _suggestions?: Array<{ provider: string; suggestion: string; file: string }> }>();

      for (const finding of findings) {
        // ... existing severity check ...

        const key = `${finding.file}:${finding.line}:${finding.title}`;
        const existing = grouped.get(key);

        const providers = new Set<string>();
        if (finding.providers) finding.providers.forEach(p => providers.add(p));
        if (finding.provider) providers.add(finding.provider);
        if (providers.size === 0) providers.add('static');

        // Track per-provider suggestions for consensus checking
        const currentSuggestions: Array<{ provider: string; suggestion: string; file: string }> = [];
        if (finding.suggestion && finding.provider) {
          currentSuggestions.push({ provider: finding.provider, suggestion: finding.suggestion, file: finding.file });
        }

        if (!existing) {
          grouped.set(key, {
            ...finding,
            providers: Array.from(providers),
            confidence: (finding.confidence ?? 0) || 1,
            _suggestions: currentSuggestions,  // Temporary for consensus checking
          });
          continue;
        }

        // Merge existing with new finding
        const mergedSuggestions = [
          ...(existing._suggestions || []),
          ...currentSuggestions
        ];

        grouped.set(key, {
          ...existing,
          providers: Array.from(new Set([...(existing.providers || []), ...providers])),
          confidence: Math.min(1, (existing.confidence ?? 0) + (finding.confidence ?? 0.5)),
          _suggestions: mergedSuggestions,
        });
      }

      // Check suggestion consensus and set hasConsensus on merged findings
      const filtered = Array.from(grouped.values())
        .filter(f => this.meetsAgreement(f.providers || []))
        .map(f => {
          // Check if we have multiple provider suggestions to compare
          if (f._suggestions && f._suggestions.length >= 2) {
            const consensus = this.checkSuggestionConsensus(f._suggestions, this.options.minAgreement);
            f.hasConsensus = consensus.hasSuggestionConsensus;
            // If consensus, use the agreed-upon suggestion
            if (consensus.hasSuggestionConsensus && consensus.suggestions.length > 0) {
              f.suggestion = consensus.suggestions[0];
            }
          }
          // Clean up temporary field
          delete (f as any)._suggestions;
          return f;
        });

      filtered.sort((a, b) => SEVERITY_ORDER[b.severity] - SEVERITY_ORDER[a.severity]);
      return filtered;
    }
    ```

    This ensures hasConsensus is set DURING aggregation when we have access to per-provider suggestions.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="consensus" --verbose
    ```
    TypeScript compiles, all consensus tests pass.
  </verify>
  <done>ConsensusEngine.filter sets hasConsensus on merged findings during aggregation.</done>
</task>

<task type="auto">
  <name>Task 4: Add consensus integration tests</name>
  <files>__tests__/analysis/consensus.test.ts</files>
  <action>
    Add test cases for checkSuggestionConsensus AND for filter setting hasConsensus:

    ```typescript
    describe('checkSuggestionConsensus', () => {
      it('should detect AST-equivalent suggestions', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'x + 1', file: 'test.ts' },
          { provider: 'gemini', suggestion: 'x+1', file: 'test.ts' },  // Same AST, different whitespace
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(true);
        expect(result.agreementCount).toBe(2);
      });

      it('should detect non-equivalent suggestions', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'x + 1', file: 'test.ts' },
          { provider: 'gemini', suggestion: 'x - 1', file: 'test.ts' },  // Different AST
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(false);
        expect(result.agreementCount).toBe(1);
      });

      it('should fall back to string comparison for unknown language', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'foo bar', file: 'test.xyz' },
          { provider: 'gemini', suggestion: 'foo bar', file: 'test.xyz' },
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(true);
      });

      it('should require minimum agreement count', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'x + 1', file: 'test.ts' },
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(false);
      });
    });

    describe('filter with hasConsensus', () => {
      it('should set hasConsensus when providers agree on suggestion', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const findings: Finding[] = [
          { file: 'test.ts', line: 10, title: 'Issue', message: 'Fix it', severity: 'minor', provider: 'claude', suggestion: 'x + 1' },
          { file: 'test.ts', line: 10, title: 'Issue', message: 'Fix it', severity: 'minor', provider: 'gemini', suggestion: 'x+1' },
        ];
        const result = engine.filter(findings);
        expect(result.length).toBe(1);
        expect(result[0].hasConsensus).toBe(true);
      });

      it('should not set hasConsensus when providers disagree', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const findings: Finding[] = [
          { file: 'test.ts', line: 10, title: 'Issue', message: 'Fix it', severity: 'minor', provider: 'claude', suggestion: 'x + 1' },
          { file: 'test.ts', line: 10, title: 'Issue', message: 'Fix it', severity: 'minor', provider: 'gemini', suggestion: 'x - 1' },
        ];
        const result = engine.filter(findings);
        expect(result.length).toBe(1);
        expect(result[0].hasConsensus).toBe(false);
      });

      it('should not set hasConsensus for single-provider findings', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const findings: Finding[] = [
          { file: 'test.ts', line: 10, title: 'Issue', message: 'Fix it', severity: 'minor', provider: 'claude', suggestion: 'x + 1' },
        ];
        const result = engine.filter(findings);
        expect(result.length).toBe(1);
        expect(result[0].hasConsensus).toBeUndefined();
      });
    });
    ```
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="consensus" --verbose
    ```
    All tests pass including new checkSuggestionConsensus and filter hasConsensus tests.
  </verify>
  <done>Consensus engine has test coverage for AST-based suggestion comparison and filter hasConsensus setting.</done>
</task>

</tasks>

<verification>
```bash
npm run typecheck && npm test -- --testPathPattern="consensus" --verbose
```
- TypeScript compiles without errors
- All consensus tests pass
- New config fields are recognized
- hasConsensus is set during filter aggregation
</verification>

<success_criteria>
- Config schema accepts min_confidence, confidence_threshold, consensus settings
- Finding type has hasConsensus field
- ConsensusEngine.checkSuggestionConsensus detects AST-equivalent suggestions
- ConsensusEngine.filter sets hasConsensus on merged findings
- Fallback to string comparison for unknown languages
- Existing consensus tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-05-SUMMARY.md`
</output>
