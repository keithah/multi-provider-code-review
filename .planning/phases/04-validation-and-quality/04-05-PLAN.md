---
phase: 04-validation-and-quality
plan: 05
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - src/config/schema.ts
  - src/types/index.ts
  - src/analysis/consensus.ts
autonomous: true

must_haves:
  truths:
    - "Config schema accepts quality threshold settings"
    - "ConsensusEngine uses AST comparison for suggestion agreement"
    - "Critical severity findings require consensus when configured"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "Quality config schema fields"
      contains: "min_confidence"
    - path: "src/analysis/consensus.ts"
      provides: "AST-based consensus for suggestions"
      contains: "areASTsEquivalent"
  key_links:
    - from: "src/analysis/consensus.ts"
      to: "src/validation/ast-comparator.ts"
      via: "import areASTsEquivalent"
      pattern: "areASTsEquivalent"
---

<objective>
Extend config schema with quality settings and integrate AST comparison into consensus engine.

Purpose: Enable configurable quality thresholds (min_confidence, per-severity) and upgrade consensus detection to use AST-based equivalence for suggestions (not just string matching).

Output: Updated config schema and consensus engine with AST-based suggestion comparison.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@src/config/schema.ts
@src/types/index.ts
@src/analysis/consensus.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config schema with quality settings</name>
  <files>src/config/schema.ts, src/types/index.ts</files>
  <action>
    Add quality configuration fields to ReviewConfigSchema (zod):

    ```typescript
    // In schema.ts, add to ReviewConfigSchema:
    min_confidence: z.number().min(0).max(1).optional(),  // Default 0.7
    confidence_threshold: z.object({
      critical: z.number().min(0).max(1).optional(),
      high: z.number().min(0).max(1).optional(),
      medium: z.number().min(0).max(1).optional(),
      low: z.number().min(0).max(1).optional(),
    }).optional(),
    consensus_required_for_critical: z.boolean().optional(),  // Default true
    consensus_min_agreement: z.number().int().min(2).optional(),  // Default 2
    suggestion_syntax_validation: z.boolean().optional(),  // Default true
    ```

    Add corresponding fields to ReviewConfig interface in types/index.ts:
    ```typescript
    minConfidence?: number;
    confidenceThreshold?: {
      critical?: number;
      high?: number;
      medium?: number;
      low?: number;
    };
    consensusRequiredForCritical?: boolean;
    consensusMinAgreement?: number;
    suggestionSyntaxValidation?: boolean;
    ```

    Do NOT change field naming convention - follow existing snake_case for schema, camelCase for interface.
  </action>
  <verify>
    ```bash
    npm run typecheck
    ```
    No TypeScript errors.
  </verify>
  <done>Config schema accepts quality settings, types updated to match.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate AST comparison into consensus engine</name>
  <files>src/analysis/consensus.ts</files>
  <action>
    Modify ConsensusEngine to detect suggestion agreement using AST comparison:

    1. Add import: `import { areASTsEquivalent } from '../validation/ast-comparator';`
    2. Add import: `import { detectLanguage } from './ast/parsers';`

    3. Add new interface for suggestion consensus:
    ```typescript
    export interface SuggestionConsensus {
      hasSuggestionConsensus: boolean;
      agreementCount: number;
      suggestions: string[];
    }
    ```

    4. Add new method to ConsensusEngine:
    ```typescript
    /**
     * Check if multiple providers' suggestions are AST-equivalent.
     * Used for critical severity findings where consensus is required.
     */
    checkSuggestionConsensus(
      suggestions: Array<{ provider: string; suggestion: string; file: string }>,
      minAgreement: number = 2
    ): SuggestionConsensus {
      if (suggestions.length < minAgreement) {
        return { hasSuggestionConsensus: false, agreementCount: 0, suggestions: [] };
      }

      const language = detectLanguage(suggestions[0].file);
      if (language === 'unknown') {
        // Can't compare ASTs for unknown language, fall back to string comparison
        return this.checkStringConsensus(suggestions, minAgreement);
      }

      // Group by AST equivalence
      const groups: string[][] = [];
      for (const s of suggestions) {
        let added = false;
        for (const group of groups) {
          const result = areASTsEquivalent(group[0], s.suggestion, language);
          if (result.equivalent) {
            group.push(s.suggestion);
            added = true;
            break;
          }
        }
        if (!added) {
          groups.push([s.suggestion]);
        }
      }

      // Find largest group
      const largestGroup = groups.reduce((a, b) => a.length > b.length ? a : b, []);

      return {
        hasSuggestionConsensus: largestGroup.length >= minAgreement,
        agreementCount: largestGroup.length,
        suggestions: largestGroup
      };
    }

    private checkStringConsensus(
      suggestions: Array<{ provider: string; suggestion: string }>,
      minAgreement: number
    ): SuggestionConsensus {
      // Fallback: exact string match (normalized whitespace)
      const normalized = suggestions.map(s => ({ ...s, normalized: s.suggestion.trim().replace(/\s+/g, ' ') }));
      const counts = new Map<string, string[]>();
      for (const s of normalized) {
        const arr = counts.get(s.normalized) || [];
        arr.push(s.suggestion);
        counts.set(s.normalized, arr);
      }
      const largest = Array.from(counts.values()).reduce((a, b) => a.length > b.length ? a : b, []);
      return {
        hasSuggestionConsensus: largest.length >= minAgreement,
        agreementCount: largest.length,
        suggestions: largest
      };
    }
    ```

    5. Export SuggestionConsensus from module.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="consensus" --verbose
    ```
    TypeScript compiles, existing consensus tests pass (new method doesn't break existing behavior).
  </verify>
  <done>ConsensusEngine.checkSuggestionConsensus uses AST comparison for language-aware equivalence detection.</done>
</task>

<task type="auto">
  <name>Task 3: Add consensus integration tests</name>
  <files>__tests__/analysis/consensus.test.ts</files>
  <action>
    Add test cases for checkSuggestionConsensus:

    ```typescript
    describe('checkSuggestionConsensus', () => {
      it('should detect AST-equivalent suggestions', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'x + 1', file: 'test.ts' },
          { provider: 'gemini', suggestion: 'x+1', file: 'test.ts' },  // Same AST, different whitespace
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(true);
        expect(result.agreementCount).toBe(2);
      });

      it('should detect non-equivalent suggestions', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'x + 1', file: 'test.ts' },
          { provider: 'gemini', suggestion: 'x - 1', file: 'test.ts' },  // Different AST
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(false);
        expect(result.agreementCount).toBe(1);
      });

      it('should fall back to string comparison for unknown language', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'foo bar', file: 'test.xyz' },
          { provider: 'gemini', suggestion: 'foo bar', file: 'test.xyz' },
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(true);
      });

      it('should require minimum agreement count', () => {
        const engine = new ConsensusEngine({ minAgreement: 2, minSeverity: 'minor', maxComments: 50 });
        const suggestions = [
          { provider: 'claude', suggestion: 'x + 1', file: 'test.ts' },
        ];
        const result = engine.checkSuggestionConsensus(suggestions, 2);
        expect(result.hasSuggestionConsensus).toBe(false);
      });
    });
    ```
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="consensus" --verbose
    ```
    All tests pass including new checkSuggestionConsensus tests.
  </verify>
  <done>Consensus engine has test coverage for AST-based suggestion comparison.</done>
</task>

</tasks>

<verification>
```bash
npm run typecheck && npm test -- --testPathPattern="consensus" --verbose
```
- TypeScript compiles without errors
- All consensus tests pass
- New config fields are recognized
</verification>

<success_criteria>
- Config schema accepts min_confidence, confidence_threshold, consensus settings
- ConsensusEngine.checkSuggestionConsensus detects AST-equivalent suggestions
- Fallback to string comparison for unknown languages
- Existing consensus tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-05-SUMMARY.md`
</output>
