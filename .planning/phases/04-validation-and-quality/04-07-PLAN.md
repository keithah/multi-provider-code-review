---
phase: 04-validation-and-quality
plan: 07
type: execute
wave: 3
depends_on: ["04-04", "04-06"]
files_modified:
  - src/learning/prompt-enrichment.ts
  - src/analysis/llm/prompt-builder.ts
  - __tests__/learning/prompt-enrichment.test.ts
autonomous: true

must_haves:
  truths:
    - "LLM prompts include learned dismissal patterns"
    - "Prompt enrichment warns about commonly rejected suggestion types"
    - "High false-positive categories are flagged in prompts"
    - "Enrichment data comes from SuppressionTracker and FeedbackTracker"
  artifacts:
    - path: "src/learning/prompt-enrichment.ts"
      provides: "PromptEnricher class"
      exports: ["PromptEnricher", "EnrichmentContext"]
    - path: "src/analysis/llm/prompt-builder.ts"
      provides: "PromptBuilder with enrichment"
      contains: "PromptEnricher|EnrichmentContext"
  key_links:
    - from: "src/learning/prompt-enrichment.ts"
      to: "src/learning/suppression-tracker.ts"
      via: "SuppressionTracker"
      pattern: "SuppressionTracker"
    - from: "src/learning/prompt-enrichment.ts"
      to: "src/learning/feedback-tracker.ts"
      via: "FeedbackTracker"
      pattern: "FeedbackTracker"
    - from: "src/analysis/llm/prompt-builder.ts"
      to: "src/learning/prompt-enrichment.ts"
      via: "PromptEnricher"
      pattern: "PromptEnricher|getEnrichmentContext"
---

<objective>
Implement prompt enrichment with learned patterns from user feedback.

Purpose: Per CONTEXT.md decision: "Pattern updates feed back into LLM prompts with learned preferences." When users dismiss suggestions, the patterns are used to:
1. Warn the LLM about commonly rejected suggestion types
2. Flag high false-positive categories
3. Include repo-specific preferences in the prompt

Output: Working `PromptEnricher` that integrates with PromptBuilder to include learned patterns.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@src/learning/suppression-tracker.ts
@src/learning/feedback-tracker.ts
@src/analysis/llm/prompt-builder.ts
@.planning/phases/04-validation-and-quality/04-04-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PromptEnricher class</name>
  <files>src/learning/prompt-enrichment.ts, __tests__/learning/prompt-enrichment.test.ts</files>
  <action>
    Create PromptEnricher that aggregates learning data for prompt injection:

    ```typescript
    import { SuppressionTracker, SuppressionPattern } from './suppression-tracker';
    import { FeedbackTracker, CategoryStats } from './feedback-tracker';
    import { logger } from '../utils/logger';

    export interface EnrichmentContext {
      suppressedCategories: string[];        // Categories with active suppressions
      lowQualityCategories: string[];        // Categories with <50% positive rate
      repoPreferences: string[];             // Human-readable preference descriptions
      promptAdditions: string[];             // Lines to add to prompt
    }

    export interface EnrichmentConfig {
      minFeedbackForLowQuality: number;      // Min feedback before flagging (default: 5)
      lowQualityThreshold: number;           // Positive rate below this is "low quality" (default: 0.5)
      maxSuppressionCategories: number;      // Max categories to mention (default: 5)
    }

    const DEFAULT_CONFIG: EnrichmentConfig = {
      minFeedbackForLowQuality: 5,
      lowQualityThreshold: 0.5,
      maxSuppressionCategories: 5
    };

    export class PromptEnricher {
      private readonly config: EnrichmentConfig;

      constructor(
        private readonly suppressionTracker?: SuppressionTracker,
        private readonly feedbackTracker?: FeedbackTracker,
        config?: Partial<EnrichmentConfig>
      ) {
        this.config = { ...DEFAULT_CONFIG, ...config };
      }

      /**
       * Get enrichment context for a specific PR.
       * Aggregates suppression patterns and feedback stats.
       */
      async getEnrichmentContext(prNumber: number): Promise<EnrichmentContext> {
        const context: EnrichmentContext = {
          suppressedCategories: [],
          lowQualityCategories: [],
          repoPreferences: [],
          promptAdditions: []
        };

        // Get suppressed categories from SuppressionTracker
        if (this.suppressionTracker) {
          const suppressions = await this.getSuppressedCategories(prNumber);
          context.suppressedCategories = suppressions.slice(0, this.config.maxSuppressionCategories);
        }

        // Get low-quality categories from FeedbackTracker
        if (this.feedbackTracker) {
          const categoryStats = await this.feedbackTracker.getCategoryStats();
          context.lowQualityCategories = this.identifyLowQualityCategories(categoryStats);
        }

        // Generate human-readable preferences
        context.repoPreferences = this.generatePreferences(context);

        // Generate prompt additions
        context.promptAdditions = this.generatePromptAdditions(context);

        return context;
      }

      /**
       * Get prompt text to inject into LLM prompt.
       * Returns empty string if no enrichment available.
       */
      async getPromptText(prNumber: number): Promise<string> {
        const context = await this.getEnrichmentContext(prNumber);

        if (context.promptAdditions.length === 0) {
          return '';
        }

        return [
          'LEARNED PREFERENCES (from user feedback in this repository):',
          ...context.promptAdditions,
          ''
        ].join('\n');
      }

      private async getSuppressedCategories(prNumber: number): Promise<string[]> {
        // This would need a method on SuppressionTracker to get active categories
        // For now, return empty - will be wired when SuppressionTracker adds this method
        // The SuppressionTracker stores patterns with categories, so this is retrievable
        try {
          // Assume SuppressionTracker has getActiveCategories method (add if not present)
          const categories = await (this.suppressionTracker as any).getActiveCategories?.(prNumber);
          return categories || [];
        } catch {
          return [];
        }
      }

      private identifyLowQualityCategories(stats: Record<string, CategoryStats>): string[] {
        return Object.values(stats)
          .filter(s =>
            s.totalFeedback >= this.config.minFeedbackForLowQuality &&
            s.positiveRate < this.config.lowQualityThreshold
          )
          .map(s => s.category)
          .slice(0, this.config.maxSuppressionCategories);
      }

      private generatePreferences(context: EnrichmentContext): string[] {
        const prefs: string[] = [];

        if (context.suppressedCategories.length > 0) {
          prefs.push(`User has dismissed suggestions in these categories: ${context.suppressedCategories.join(', ')}`);
        }

        if (context.lowQualityCategories.length > 0) {
          prefs.push(`These categories have high false-positive rates: ${context.lowQualityCategories.join(', ')}`);
        }

        return prefs;
      }

      private generatePromptAdditions(context: EnrichmentContext): string[] {
        const additions: string[] = [];

        if (context.suppressedCategories.length > 0) {
          additions.push(
            `- AVOID suggesting fixes in these categories (recently dismissed): ${context.suppressedCategories.join(', ')}`
          );
        }

        if (context.lowQualityCategories.length > 0) {
          additions.push(
            `- BE EXTRA CAREFUL with these categories (high false-positive history): ${context.lowQualityCategories.join(', ')}`
          );
        }

        return additions;
      }
    }
    ```

    Create test file with cases:
    - Empty enrichment when no trackers provided
    - Suppressed categories appear in context
    - Low-quality categories identified correctly
    - Prompt text generation
    - Max categories limit respected
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="prompt-enrichment" --verbose
    ```
    All tests pass.
  </verify>
  <done>PromptEnricher aggregates learning data and generates prompt additions.</done>
</task>

<task type="auto">
  <name>Task 2: Add getActiveCategories to SuppressionTracker</name>
  <files>src/learning/suppression-tracker.ts</files>
  <action>
    Add method to SuppressionTracker for retrieving active suppression categories:

    ```typescript
    /**
     * Get categories with active suppressions for a PR.
     * Used by PromptEnricher to inform LLM about dismissed categories.
     */
    async getActiveCategories(prNumber: number): Promise<string[]> {
      const data = await this.loadData();
      const now = Date.now();

      // Filter to non-expired patterns matching this PR or repo-wide
      const activePatterns = data.patterns.filter(p =>
        p.expiresAt > now &&
        (p.scope === 'repo' || (p.scope === 'pr' && p.prNumber === prNumber))
      );

      // Get unique categories
      const categories = [...new Set(activePatterns.map(p => p.category))];

      return categories;
    }
    ```

    Export the method in the class.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="suppression-tracker" --verbose
    ```
    TypeScript compiles, tests pass.
  </verify>
  <done>SuppressionTracker exposes active categories for prompt enrichment.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate PromptEnricher into PromptBuilder</name>
  <files>src/analysis/llm/prompt-builder.ts</files>
  <action>
    Wire PromptEnricher into PromptBuilder to include learned patterns:

    1. Add import:
    ```typescript
    import { PromptEnricher } from '../learning/prompt-enrichment';
    ```

    2. Add optional enricher parameter to constructor:
    ```typescript
    constructor(
      private readonly config: ReviewConfig,
      private readonly intensity: ReviewIntensity = 'standard',
      private readonly codeGraph?: CodeGraph,
      private readonly promptEnricher?: PromptEnricher
    ) {
      // ... existing validation
    }
    ```

    3. Add optional prNumber parameter to build methods:
    ```typescript
    async build(pr: PRContext, prNumber?: number): Promise<string> {
      // ... existing validation ...

      // Get learned preferences if enricher available
      let learnedPreferences = '';
      if (this.promptEnricher && prNumber) {
        try {
          learnedPreferences = await this.promptEnricher.getPromptText(prNumber);
        } catch (error) {
          logger.debug('Failed to get prompt enrichment:', error as Error);
        }
      }

      // ... existing code ...

      // After defensive context and code graph context, add learned preferences
      if (learnedPreferences) {
        instructions.push(learnedPreferences);
      }

      // ... rest of method ...
    }
    ```

    4. Note: This makes build() async. Update buildWithValidation and buildOptimized to await build().

    5. Add backward-compatible overloads or handle undefined prNumber gracefully.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="prompt-builder" --verbose
    ```
    TypeScript compiles, existing tests pass (with async updates if needed).
  </verify>
  <done>PromptBuilder includes learned patterns from user feedback in LLM prompts.</done>
</task>

</tasks>

<verification>
```bash
npm run typecheck && npm test -- --testPathPattern="prompt-enrichment|suppression-tracker|prompt-builder" --verbose
```
- All TypeScript compiles
- All tests pass
- Learned patterns appear in generated prompts
</verification>

<success_criteria>
- PromptEnricher aggregates suppression and feedback data
- SuppressionTracker exposes active categories
- PromptBuilder includes learned preferences in prompts
- High false-positive categories flagged to LLM
- Dismissed suggestion categories warned against
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-07-SUMMARY.md`
</output>
