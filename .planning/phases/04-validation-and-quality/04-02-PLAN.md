---
phase: 04-validation-and-quality
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/validation/ast-comparator.ts
  - __tests__/validation/ast-comparator.test.ts
autonomous: true

must_haves:
  truths:
    - "Semantically identical code with different whitespace is considered equivalent"
    - "Structurally different code is detected as non-equivalent"
    - "Variable name differences are ignored (AST structure match)"
    - "Different node types cause non-equivalence"
  artifacts:
    - path: "src/validation/ast-comparator.ts"
      provides: "areASTsEquivalent function"
      exports: ["areASTsEquivalent", "ASTComparisonResult"]
    - path: "__tests__/validation/ast-comparator.test.ts"
      provides: "AST comparator tests"
      contains: "describe.*AST"
  key_links:
    - from: "src/validation/ast-comparator.ts"
      to: "tree-sitter"
      via: "parser.parse"
      pattern: "parser\\.parse"
---

<objective>
TDD implementation of AST-based comparison for detecting structural equivalence between code suggestions.

Purpose: Enable consensus detection by comparing suggestions from multiple providers. Two suggestions are "equivalent" if their AST structures match (ignoring whitespace and variable names). Per CONTEXT.md, this is used for critical severity consensus (2-of-N providers must agree).

Output: Working `areASTsEquivalent` function with tests covering whitespace, variable names, and structural differences.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@.planning/phases/04-validation-and-quality/04-RESEARCH.md
@src/analysis/ast/parsers.ts
</context>

<feature>
  <name>AST Comparator</name>
  <files>src/validation/ast-comparator.ts, __tests__/validation/ast-comparator.test.ts</files>
  <behavior>
    areASTsEquivalent(code1: string, code2: string, language: Language) -> ASTComparisonResult

    Cases (TypeScript examples):
    - Whitespace diff: `x + 1` vs `x+1` -> { equivalent: true }
    - Same structure: `const x = 1;` vs `const y = 2;` -> { equivalent: true } (different identifiers/values OK)
    - Different structure: `x + 1` vs `x - 1` -> { equivalent: false, reason: 'Node type mismatch' }
    - Different child count: `foo(a)` vs `foo(a, b)` -> { equivalent: false, reason: 'Child count mismatch' }
    - Parse failure: invalid code -> { equivalent: false, reason: 'Parse error in code1/code2' }
    - Unsupported language: -> { equivalent: false, reason: 'Unsupported language' }

    Comparison rules:
    1. Compare node types (must match)
    2. Compare named child counts (must match)
    3. Recursively compare children
    4. For identifier nodes: ignore actual names (structure match only)
    5. For literal nodes: ignore values (numbers, strings - structure match only)
  </behavior>
  <implementation>
    1. Parse both code strings with tree-sitter
    2. Implement recursive node comparison
    3. Handle identifier/literal nodes specially (match type, not content)
    4. Return detailed result with mismatch reason

    Interface:
    ```typescript
    interface ASTComparisonResult {
      equivalent: boolean;
      reason?: string;           // Why not equivalent (if false)
      comparisonDepth?: number;  // How deep the comparison went
    }

    function areASTsEquivalent(
      code1: string,
      code2: string,
      language: Language
    ): ASTComparisonResult
    ```

    Node types to treat as "value-only" (compare type but not content):
    - identifier, property_identifier, type_identifier
    - string, number, true, false, null
    - template_string, regex
  </implementation>
</feature>

<verification>
```bash
npm test -- --testPathPattern="ast-comparator" --verbose
```
All tests pass. Coverage includes:
- Whitespace equivalence
- Variable name equivalence
- Structural differences (operators, child count)
- Parse failure handling
- Unsupported language handling
</verification>

<success_criteria>
- RED: Tests fail because areASTsEquivalent doesn't exist
- GREEN: Tests pass with recursive comparison
- REFACTOR: Extract node comparison logic, add depth limit for performance
- Whitespace differences don't affect equivalence
- Identifier/literal names don't affect equivalence
- Structural differences (node types, child counts) cause non-equivalence
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-02-SUMMARY.md`
</output>
