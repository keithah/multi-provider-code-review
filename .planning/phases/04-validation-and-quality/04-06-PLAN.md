---
phase: 04-validation-and-quality
plan: 06
type: execute
wave: 3
depends_on: ["04-01", "04-03", "04-04", "04-05"]
files_modified:
  - src/validation/index.ts
  - src/github/comment-poster.ts
  - src/analytics/metrics-collector.ts
autonomous: true

must_haves:
  truths:
    - "Suggestions are syntax validated before posting"
    - "Invalid syntax suggestions are silently degraded to description-only"
    - "Suppressed suggestions are not posted"
    - "Quality metrics are logged for analytics"
  artifacts:
    - path: "src/validation/index.ts"
      provides: "Validation module exports"
      exports: ["validateSyntax", "areASTsEquivalent", "calculateConfidence", "shouldPostSuggestion"]
    - path: "src/github/comment-poster.ts"
      provides: "Quality-gated comment posting"
      contains: "validateSyntax"
  key_links:
    - from: "src/github/comment-poster.ts"
      to: "src/validation/index.ts"
      via: "import validateSyntax"
      pattern: "validateSyntax|shouldPostSuggestion"
---

<objective>
Integrate validation pipeline into comment posting flow and add quality metrics.

Purpose: Wire the validation modules (syntax validator, confidence calculator, suppression tracker) into the actual suggestion posting flow. Suggestions that fail validation or are suppressed degrade gracefully to description-only comments. Quality metrics are captured for analytics.

Output: Complete quality gate pipeline in comment-poster with metrics integration.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@src/github/comment-poster.ts
@src/analytics/metrics-collector.ts
@.planning/phases/04-validation-and-quality/04-01-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-03-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation module index</name>
  <files>src/validation/index.ts</files>
  <action>
    Create barrel export for validation module:

    ```typescript
    /**
     * Validation module for suggestion quality gates.
     *
     * This module provides:
     * - Syntax validation using tree-sitter
     * - AST comparison for consensus detection
     * - Confidence scoring combining LLM + validation signals
     * - Threshold-based filtering for suggestion posting
     */

    export {
      validateSyntax,
      SyntaxValidationResult
    } from './syntax-validator';

    export {
      areASTsEquivalent,
      ASTComparisonResult
    } from './ast-comparator';

    export {
      calculateConfidence,
      shouldPostSuggestion,
      ConfidenceSignals,
      QualityConfig
    } from './confidence-calculator';
    ```

    Ensure all exports are properly typed and documented.
  </action>
  <verify>
    ```bash
    npm run typecheck
    ```
    TypeScript compiles without errors.
  </verify>
  <done>Validation module has clean public API via index.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into comment-poster</name>
  <files>src/github/comment-poster.ts</files>
  <action>
    Add validation pipeline to postInline method:

    1. Add imports at top:
    ```typescript
    import { validateSyntax, shouldPostSuggestion, calculateConfidence, ConfidenceSignals } from '../validation';
    import { SuppressionTracker } from '../learning/suppression-tracker';
    import { detectLanguage } from '../analysis/ast/parsers';
    ```

    2. Add constructor parameters:
    ```typescript
    constructor(
      private readonly client: GitHubClient,
      private readonly dryRun: boolean = false,
      private readonly config?: Partial<ReviewConfig>,
      private readonly suppressionTracker?: SuppressionTracker
    ) {}
    ```

    3. Add private method for suggestion validation:
    ```typescript
    private async validateAndFilterSuggestion(
      comment: InlineComment & { suggestion?: string; category?: string; severity?: Severity },
      prNumber: number
    ): Promise<{ valid: boolean; reason?: string }> {
      if (!comment.suggestion) {
        return { valid: true }; // No suggestion to validate
      }

      // Check suppression first (fast path)
      if (this.suppressionTracker) {
        const suppressed = await this.suppressionTracker.shouldSuppress(
          { category: comment.category || 'unknown', file: comment.path, line: comment.line },
          prNumber
        );
        if (suppressed) {
          logger.debug(`Suggestion suppressed for ${comment.path}:${comment.line} (similar suggestion dismissed)`);
          return { valid: false, reason: 'Similar suggestion was dismissed' };
        }
      }

      // Syntax validation (if enabled)
      if (this.config?.suggestionSyntaxValidation !== false) {
        const language = detectLanguage(comment.path);
        if (language !== 'unknown') {
          const syntaxResult = validateSyntax(comment.suggestion, language);
          if (!syntaxResult.isValid && !syntaxResult.skipped) {
            logger.debug(`Suggestion syntax invalid for ${comment.path}:${comment.line}: ${syntaxResult.errors.length} error(s)`);
            return { valid: false, reason: 'Syntax validation failed' };
          }
        }
      }

      // Confidence threshold check
      if (comment.severity && this.config) {
        const signals: ConfidenceSignals = {
          llmConfidence: (comment as any).confidence,
          syntaxValid: true, // Already validated above
          hasConsensus: false, // TODO: integrate with consensus engine
          providerReliability: 1.0 // TODO: get from reliability tracker
        };
        const confidence = calculateConfidence(signals);

        if (!shouldPostSuggestion(
          { severity: comment.severity, providers: (comment as any).providers },
          confidence,
          {
            min_confidence: this.config.minConfidence,
            confidence_threshold: this.config.confidenceThreshold,
            consensus: {
              required_for_critical: this.config.consensusRequiredForCritical ?? true,
              min_agreement: this.config.consensusMinAgreement ?? 2
            }
          }
        )) {
          logger.debug(`Suggestion below confidence threshold for ${comment.path}:${comment.line}`);
          return { valid: false, reason: 'Below confidence threshold' };
        }
      }

      return { valid: true };
    }
    ```

    4. In postInline, after the suggestion block detection (where it checks `c.body.includes('```suggestion')`), add validation:
    ```typescript
    // After existing suggestion block detection, before posting:
    if (c.body.includes('```suggestion')) {
      const validation = await this.validateAndFilterSuggestion(
        { ...c, suggestion: /* extract suggestion content */, category: (c as any).category, severity: (c as any).severity },
        prNumber
      );
      if (!validation.valid) {
        // Remove suggestion block, keep description
        c.body = c.body.replace(/```suggestion[\s\S]*?```/g, `_Suggestion not available: ${validation.reason}_`);
      }
    }
    ```

    5. Track quality metrics (add after validation):
    ```typescript
    // Track validation results for analytics
    const qualityMetrics = {
      validated: true,
      syntaxValid: true,
      suppressed: false,
      belowThreshold: false
    };
    // These will be collected by metrics system
    ```

    IMPORTANT: Do NOT break existing validation logic (isSuggestionLineValid, validateSuggestionRange). Add new validation as additional layer.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="comment-poster" --verbose
    ```
    TypeScript compiles, existing tests pass.
  </verify>
  <done>Comment poster validates suggestions through quality pipeline before posting.</done>
</task>

<task type="auto">
  <name>Task 3: Add quality metrics to analytics</name>
  <files>src/analytics/metrics-collector.ts</files>
  <action>
    Extend MetricsCollector to track suggestion quality metrics:

    1. Add interface for suggestion metrics:
    ```typescript
    export interface SuggestionQualityMetric {
      timestamp: number;
      prNumber: number;
      file: string;
      line: number;
      syntaxValid: boolean;
      suppressed: boolean;
      confidenceScore: number;
      posted: boolean;
      reason?: string;  // Why not posted (if !posted)
    }
    ```

    2. Extend MetricsData:
    ```typescript
    export interface MetricsData {
      reviews: ReviewMetric[];
      suggestionQuality: SuggestionQualityMetric[];  // NEW
      // ... existing fields
    }
    ```

    3. Add method to record suggestion quality:
    ```typescript
    async recordSuggestionQuality(metric: Omit<SuggestionQualityMetric, 'timestamp'>): Promise<void> {
      const data = await this.loadData();

      data.suggestionQuality = data.suggestionQuality || [];
      data.suggestionQuality.push({
        ...metric,
        timestamp: Date.now()
      });

      // Keep only last N suggestion metrics
      const maxSuggestions = (this.config?.analyticsMaxReviews || 1000) * 10; // 10x reviews
      if (data.suggestionQuality.length > maxSuggestions) {
        data.suggestionQuality = data.suggestionQuality.slice(-maxSuggestions);
      }

      await this.saveData(data);
      logger.debug(`Recorded suggestion quality metric for ${metric.file}:${metric.line}`);
    }
    ```

    4. Add method to get suggestion quality stats:
    ```typescript
    async getSuggestionQualityStats(): Promise<{
      totalSuggestions: number;
      syntaxValidRate: number;
      suppressionRate: number;
      avgConfidence: number;
      postRate: number;
    }> {
      const data = await this.loadData();
      const suggestions = data.suggestionQuality || [];

      if (suggestions.length === 0) {
        return {
          totalSuggestions: 0,
          syntaxValidRate: 0,
          suppressionRate: 0,
          avgConfidence: 0,
          postRate: 0
        };
      }

      const syntaxValid = suggestions.filter(s => s.syntaxValid).length;
      const suppressed = suggestions.filter(s => s.suppressed).length;
      const posted = suggestions.filter(s => s.posted).length;
      const totalConfidence = suggestions.reduce((sum, s) => sum + s.confidenceScore, 0);

      return {
        totalSuggestions: suggestions.length,
        syntaxValidRate: syntaxValid / suggestions.length,
        suppressionRate: suppressed / suggestions.length,
        avgConfidence: totalConfidence / suggestions.length,
        postRate: posted / suggestions.length
      };
    }
    ```

    5. Update loadData to handle missing suggestionQuality array (backward compatibility).
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="metrics" --verbose
    ```
    TypeScript compiles, existing metrics tests pass.
  </verify>
  <done>Quality metrics for suggestions are tracked in analytics system.</done>
</task>

</tasks>

<verification>
```bash
npm run typecheck && npm test --verbose
```
- All TypeScript compiles
- All tests pass
- No regressions in existing functionality
</verification>

<success_criteria>
- Validation module has clean exports via index.ts
- CommentPoster validates suggestions before posting
- Invalid/suppressed suggestions degrade to description-only
- Quality metrics captured for analytics dashboard
- Existing comment posting behavior unchanged for non-suggestion comments
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-06-SUMMARY.md`
</output>
