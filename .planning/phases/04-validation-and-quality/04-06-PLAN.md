---
phase: 04-validation-and-quality
plan: 06
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03", "04-04", "04-05"]
files_modified:
  - src/validation/index.ts
  - src/github/comment-poster.ts
  - src/analytics/metrics-collector.ts
  - src/analysis/llm/prompt-builder.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Suggestions are syntax validated before posting"
    - "Invalid syntax suggestions are silently degraded to description-only"
    - "Suppressed suggestions are not posted"
    - "Quality metrics are logged for analytics"
    - "Consensus status is read from Finding.hasConsensus (set during aggregation)"
    - "Fix prompts include relevant code graph context"
  artifacts:
    - path: "src/validation/index.ts"
      provides: "Validation module exports"
      exports: ["validateSyntax", "areASTsEquivalent", "calculateConfidence", "shouldPostSuggestion"]
    - path: "src/github/comment-poster.ts"
      provides: "Quality-gated comment posting"
      contains: "validateSyntax"
    - path: "src/types/index.ts"
      provides: "Finding type with hasConsensus field"
      contains: "hasConsensus"
    - path: "src/analysis/llm/prompt-builder.ts"
      provides: "Context-aware prompts with code graph"
      contains: "CodeGraph"
  key_links:
    - from: "src/github/comment-poster.ts"
      to: "src/validation/index.ts"
      via: "import validateSyntax"
      pattern: "validateSyntax|shouldPostSuggestion"
    - from: "src/analysis/llm/prompt-builder.ts"
      to: "src/analysis/context/graph-builder.ts"
      via: "CodeGraph"
      pattern: "CodeGraph|getCallContext"
---

<objective>
Integrate validation pipeline into comment posting flow, read consensus from findings, add code graph context to prompts, and add quality metrics.

Purpose: Wire the validation modules (syntax validator, confidence calculator, suppression tracker) into the actual suggestion posting flow. Consensus is checked DURING aggregation (Plan 05) where per-provider suggestions are available - the result is stored on Finding.hasConsensus. Include code graph context in fix generation prompts (FR-4.3). Suggestions that fail validation or are suppressed degrade gracefully to description-only comments. Quality metrics are captured for analytics.

NOTE: Consensus checking happens during finding aggregation (when we have access to per-provider suggestions), NOT during comment posting. Comment-poster reads the pre-computed `hasConsensus` flag from the Finding.

Output: Complete quality gate pipeline in comment-poster with metrics integration and context-aware prompts.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@src/github/comment-poster.ts
@src/analytics/metrics-collector.ts
@src/analysis/llm/prompt-builder.ts
@src/analysis/context/graph-builder.ts
@src/types/index.ts
@.planning/phases/04-validation-and-quality/04-01-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-03-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-04-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hasConsensus field to Finding type</name>
  <files>src/types/index.ts</files>
  <action>
    Extend the Finding interface to include consensus result from aggregation:

    ```typescript
    export interface Finding {
      file: string;
      line: number;
      severity: Severity;
      title: string;
      message: string;
      suggestion?: string;
      provider?: string;
      providers?: string[];
      confidence?: number;
      category?: string;
      evidence?: EvidenceScore;
      evidenceDetail?: EvidenceDetail;
      hasConsensus?: boolean;  // NEW: Set during aggregation when multiple providers agree
    }
    ```

    This field is set during consensus checking in the aggregation phase (Plan 05's ConsensusEngine.checkSuggestionConsensus), where we have access to per-provider suggestions. Comment-poster reads this pre-computed value.
  </action>
  <verify>
    ```bash
    npm run typecheck
    ```
    TypeScript compiles without errors.
  </verify>
  <done>Finding type has hasConsensus field for storing aggregation-time consensus result.</done>
</task>

<task type="auto">
  <name>Task 2: Create validation module index</name>
  <files>src/validation/index.ts</files>
  <action>
    Create barrel export for validation module:

    ```typescript
    /**
     * Validation module for suggestion quality gates.
     *
     * This module provides:
     * - Syntax validation using tree-sitter
     * - AST comparison for consensus detection
     * - Confidence scoring combining LLM + validation signals
     * - Threshold-based filtering for suggestion posting
     */

    export {
      validateSyntax,
      SyntaxValidationResult
    } from './syntax-validator';

    export {
      areASTsEquivalent,
      ASTComparisonResult
    } from './ast-comparator';

    export {
      calculateConfidence,
      shouldPostSuggestion,
      ConfidenceSignals,
      QualityConfig
    } from './confidence-calculator';
    ```

    Ensure all exports are properly typed and documented.
  </action>
  <verify>
    ```bash
    npm run typecheck
    ```
    TypeScript compiles without errors.
  </verify>
  <done>Validation module has clean public API via index.ts.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate validation into comment-poster (read consensus from Finding)</name>
  <files>src/github/comment-poster.ts</files>
  <action>
    Add validation pipeline to postInline method, reading consensus from Finding.hasConsensus:

    1. Add imports at top:
    ```typescript
    import { validateSyntax, shouldPostSuggestion, calculateConfidence, ConfidenceSignals } from '../validation';
    import { SuppressionTracker } from '../learning/suppression-tracker';
    import { ProviderWeightTracker } from '../learning/provider-weights';
    import { detectLanguage } from '../analysis/ast/parsers';
    ```

    2. Add constructor parameters:
    ```typescript
    constructor(
      private readonly client: GitHubClient,
      private readonly dryRun: boolean = false,
      private readonly config?: Partial<ReviewConfig>,
      private readonly suppressionTracker?: SuppressionTracker,
      private readonly providerWeightTracker?: ProviderWeightTracker
    ) {}
    ```

    3. Add private method for suggestion validation (reads hasConsensus from comment):
    ```typescript
    private async validateAndFilterSuggestion(
      comment: InlineComment & {
        suggestion?: string;
        category?: string;
        severity?: Severity;
        provider?: string;
        hasConsensus?: boolean;  // Pre-computed during aggregation
        confidence?: number;
      },
      prNumber: number
    ): Promise<{ valid: boolean; reason?: string; hasConsensus?: boolean }> {
      if (!comment.suggestion) {
        return { valid: true }; // No suggestion to validate
      }

      // Check suppression first (fast path)
      if (this.suppressionTracker) {
        const suppressed = await this.suppressionTracker.shouldSuppress(
          { category: comment.category || 'unknown', file: comment.path, line: comment.line },
          prNumber
        );
        if (suppressed) {
          logger.debug(`Suggestion suppressed for ${comment.path}:${comment.line} (similar suggestion dismissed)`);
          return { valid: false, reason: 'Similar suggestion was dismissed' };
        }
      }

      // Syntax validation (if enabled)
      let syntaxValid = true;
      if (this.config?.suggestionSyntaxValidation !== false) {
        const language = detectLanguage(comment.path);
        if (language !== 'unknown') {
          const syntaxResult = validateSyntax(comment.suggestion, language);
          if (!syntaxResult.isValid && !syntaxResult.skipped) {
            logger.debug(`Suggestion syntax invalid for ${comment.path}:${comment.line}: ${syntaxResult.errors.length} error(s)`);
            syntaxValid = false;
            // Don't return early - check consensus which might override
          }
        }
      }

      // Read consensus from Finding (set during aggregation, NOT computed here)
      // Consensus checking requires per-provider suggestions which aren't available at comment-posting time
      const hasConsensus = comment.hasConsensus ?? false;
      if (hasConsensus) {
        logger.debug(`Consensus detected for ${comment.path}:${comment.line} (providers agreed during aggregation)`);
      }

      // If syntax invalid and no consensus to override, reject
      if (!syntaxValid && !hasConsensus) {
        return { valid: false, reason: 'Syntax validation failed', hasConsensus: false };
      }

      // Confidence threshold check
      if (comment.severity && this.config) {
        // Get provider weight for reliability signal
        let providerReliability = 1.0;
        if (this.providerWeightTracker && comment.provider) {
          providerReliability = await this.providerWeightTracker.getWeight(comment.provider);
        }

        const signals: ConfidenceSignals = {
          llmConfidence: comment.confidence,
          syntaxValid,
          hasConsensus,
          providerReliability
        };
        const confidence = calculateConfidence(signals);

        if (!shouldPostSuggestion(
          { severity: comment.severity, hasConsensus },
          confidence,
          {
            min_confidence: this.config.minConfidence,
            confidence_threshold: this.config.confidenceThreshold,
            consensus: {
              required_for_critical: this.config.consensusRequiredForCritical ?? true,
              min_agreement: this.config.consensusMinAgreement ?? 2
            }
          }
        )) {
          logger.debug(`Suggestion below confidence threshold for ${comment.path}:${comment.line} (confidence: ${confidence.toFixed(2)})`);
          return { valid: false, reason: 'Below confidence threshold', hasConsensus };
        }
      }

      return { valid: true, hasConsensus };
    }
    ```

    4. In postInline, after the suggestion block detection, add validation:
    ```typescript
    // After existing suggestion block detection, before posting:
    if (c.body.includes('```suggestion')) {
      const validation = await this.validateAndFilterSuggestion(
        {
          ...c,
          suggestion: /* extract suggestion content */,
          category: (c as any).category,
          severity: (c as any).severity,
          provider: (c as any).provider,
          hasConsensus: (c as any).hasConsensus,
          confidence: (c as any).confidence
        },
        prNumber
      );
      if (!validation.valid) {
        // Remove suggestion block, keep description
        c.body = c.body.replace(/```suggestion[\s\S]*?```/g, `_Suggestion not available: ${validation.reason}_`);
      }
    }
    ```

    IMPORTANT: Do NOT break existing validation logic (isSuggestionLineValid, validateSuggestionRange). Add new validation as additional layer.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="comment-poster" --verbose
    ```
    TypeScript compiles, existing tests pass.
  </verify>
  <done>Comment poster validates suggestions through quality pipeline, reading pre-computed consensus from Finding.</done>
</task>

<task type="auto">
  <name>Task 4: Add code graph context to PromptBuilder (FR-4.3)</name>
  <files>src/analysis/llm/prompt-builder.ts</files>
  <action>
    Extend PromptBuilder to include code graph context for better fix suggestions:

    1. Add import:
    ```typescript
    import { CodeGraph } from '../context/graph-builder';
    ```

    2. Add optional codeGraph parameter to constructor:
    ```typescript
    constructor(
      private readonly config: ReviewConfig,
      private readonly intensity: ReviewIntensity = 'standard',
      private readonly codeGraph?: CodeGraph
    ) {
      // ... existing validation
    }
    ```

    3. Add method to extract relevant context for a file/line:
    ```typescript
    /**
     * Get call context from code graph for better fix suggestions.
     * Returns callers and callees for symbols near the target line.
     */
    private getCallContext(file: string, line: number): string | null {
      if (!this.codeGraph) {
        return null;
      }

      try {
        // Find symbols defined in this file
        const fileSymbols = this.codeGraph.getFileSymbols(file);
        if (!fileSymbols || fileSymbols.length === 0) {
          return null;
        }

        // Find symbol closest to the target line
        const nearbySymbol = fileSymbols
          .map(name => this.codeGraph!.getDefinition(file, name))
          .filter((def): def is Definition => def !== null && Math.abs(def.line - line) <= 20)
          .sort((a, b) => Math.abs(a.line - line) - Math.abs(b.line - line))[0];

        if (!nearbySymbol) {
          return null;
        }

        // Get callers and callees
        const callers = this.codeGraph.getCallers(nearbySymbol.name) || [];
        const callees = this.codeGraph.getCalls(nearbySymbol.name) || [];

        if (callers.length === 0 && callees.length === 0) {
          return null;
        }

        const context: string[] = [];
        context.push(`CALL CONTEXT for ${nearbySymbol.name} (${nearbySymbol.type}):`);

        if (callers.length > 0) {
          context.push(`  Called by: ${callers.slice(0, 5).join(', ')}${callers.length > 5 ? ` (+${callers.length - 5} more)` : ''}`);
        }
        if (callees.length > 0) {
          context.push(`  Calls: ${callees.slice(0, 5).join(', ')}${callees.length > 5 ? ` (+${callees.length - 5} more)` : ''}`);
        }

        return context.join('\n');
      } catch (error) {
        logger.debug('Failed to get call context:', error as Error);
        return null;
      }
    }
    ```

    4. Update build() to include call context in instructions when available:
    After the defensive context injection (around line 126), add:
    ```typescript
    // Add call context from code graph if available (FR-4.3: context-aware fixes)
    if (this.codeGraph && pr.files.length > 0) {
      // Get context for files in the diff (limit to first 3 to avoid prompt bloat)
      const contextFiles = pr.files.slice(0, 3);
      const callContexts: string[] = [];

      for (const file of contextFiles) {
        // Get context for the middle of the file as a heuristic
        const midLine = Math.floor((file.additions + file.deletions) / 2) || 1;
        const context = this.getCallContext(file.filename, midLine);
        if (context) {
          callContexts.push(`${file.filename}:\n${context}`);
        }
      }

      if (callContexts.length > 0) {
        instructions.push(
          'CODE GRAPH CONTEXT (use this to understand call relationships):',
          ...callContexts,
          ''
        );
      }
    }
    ```

    5. Export Definition type if not already exported from graph-builder.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="prompt-builder" --verbose
    ```
    TypeScript compiles, existing prompt builder tests pass.
  </verify>
  <done>PromptBuilder includes code graph call context for context-aware fix suggestions.</done>
</task>

<task type="auto">
  <name>Task 5: Add quality metrics to analytics</name>
  <files>src/analytics/metrics-collector.ts</files>
  <action>
    Extend MetricsCollector to track suggestion quality metrics:

    1. Add interface for suggestion metrics:
    ```typescript
    export interface SuggestionQualityMetric {
      timestamp: number;
      prNumber: number;
      file: string;
      line: number;
      syntaxValid: boolean;
      suppressed: boolean;
      hasConsensus: boolean;
      confidenceScore: number;
      posted: boolean;
      reason?: string;  // Why not posted (if !posted)
    }
    ```

    2. Extend MetricsData:
    ```typescript
    export interface MetricsData {
      reviews: ReviewMetric[];
      suggestionQuality: SuggestionQualityMetric[];  // NEW
      // ... existing fields
    }
    ```

    3. Add method to record suggestion quality:
    ```typescript
    async recordSuggestionQuality(metric: Omit<SuggestionQualityMetric, 'timestamp'>): Promise<void> {
      const data = await this.loadData();

      data.suggestionQuality = data.suggestionQuality || [];
      data.suggestionQuality.push({
        ...metric,
        timestamp: Date.now()
      });

      // Keep only last N suggestion metrics
      const maxSuggestions = (this.config?.analyticsMaxReviews || 1000) * 10; // 10x reviews
      if (data.suggestionQuality.length > maxSuggestions) {
        data.suggestionQuality = data.suggestionQuality.slice(-maxSuggestions);
      }

      await this.saveData(data);
      logger.debug(`Recorded suggestion quality metric for ${metric.file}:${metric.line}`);
    }
    ```

    4. Add method to get suggestion quality stats:
    ```typescript
    async getSuggestionQualityStats(): Promise<{
      totalSuggestions: number;
      syntaxValidRate: number;
      suppressionRate: number;
      consensusRate: number;
      avgConfidence: number;
      postRate: number;
    }> {
      const data = await this.loadData();
      const suggestions = data.suggestionQuality || [];

      if (suggestions.length === 0) {
        return {
          totalSuggestions: 0,
          syntaxValidRate: 0,
          suppressionRate: 0,
          consensusRate: 0,
          avgConfidence: 0,
          postRate: 0
        };
      }

      const syntaxValid = suggestions.filter(s => s.syntaxValid).length;
      const suppressed = suggestions.filter(s => s.suppressed).length;
      const hasConsensus = suggestions.filter(s => s.hasConsensus).length;
      const posted = suggestions.filter(s => s.posted).length;
      const totalConfidence = suggestions.reduce((sum, s) => sum + s.confidenceScore, 0);

      return {
        totalSuggestions: suggestions.length,
        syntaxValidRate: syntaxValid / suggestions.length,
        suppressionRate: suppressed / suggestions.length,
        consensusRate: hasConsensus / suggestions.length,
        avgConfidence: totalConfidence / suggestions.length,
        postRate: posted / suggestions.length
      };
    }
    ```

    5. Update loadData to handle missing suggestionQuality array (backward compatibility).
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="metrics" --verbose
    ```
    TypeScript compiles, existing metrics tests pass.
  </verify>
  <done>Quality metrics for suggestions are tracked in analytics system with consensus tracking.</done>
</task>

</tasks>

<verification>
```bash
npm run typecheck && npm test --verbose
```
- All TypeScript compiles
- All tests pass
- No regressions in existing functionality
</verification>

<success_criteria>
- Finding type has hasConsensus field
- Validation module has clean exports via index.ts
- CommentPoster validates suggestions before posting
- Consensus is READ from Finding.hasConsensus (not computed at post time)
- PromptBuilder includes code graph context (FR-4.3)
- Invalid/suppressed suggestions degrade to description-only
- Quality metrics captured for analytics dashboard
- Existing comment posting behavior unchanged for non-suggestion comments
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-06-SUMMARY.md`
</output>
