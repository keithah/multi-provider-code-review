---
phase: 04-validation-and-quality
plan: 06
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03", "04-04", "04-05"]
files_modified:
  - src/validation/index.ts
  - src/github/comment-poster.ts
  - src/analytics/metrics-collector.ts
  - src/analysis/llm/prompt-builder.ts
autonomous: true

must_haves:
  truths:
    - "Suggestions are syntax validated before posting"
    - "Invalid syntax suggestions are silently degraded to description-only"
    - "Suppressed suggestions are not posted"
    - "Quality metrics are logged for analytics"
    - "Consensus engine is wired for suggestion agreement detection"
    - "Fix prompts include relevant code graph context"
  artifacts:
    - path: "src/validation/index.ts"
      provides: "Validation module exports"
      exports: ["validateSyntax", "areASTsEquivalent", "calculateConfidence", "shouldPostSuggestion"]
    - path: "src/github/comment-poster.ts"
      provides: "Quality-gated comment posting"
      contains: "validateSyntax"
    - path: "src/analysis/llm/prompt-builder.ts"
      provides: "Context-aware prompts with code graph"
      contains: "CodeGraph"
  key_links:
    - from: "src/github/comment-poster.ts"
      to: "src/validation/index.ts"
      via: "import validateSyntax"
      pattern: "validateSyntax|shouldPostSuggestion"
    - from: "src/github/comment-poster.ts"
      to: "src/analysis/consensus.ts"
      via: "checkSuggestionConsensus"
      pattern: "checkSuggestionConsensus"
    - from: "src/analysis/llm/prompt-builder.ts"
      to: "src/analysis/context/graph-builder.ts"
      via: "CodeGraph"
      pattern: "CodeGraph|getCallContext"
---

<objective>
Integrate validation pipeline into comment posting flow, wire consensus engine, add code graph context to prompts, and add quality metrics.

Purpose: Wire the validation modules (syntax validator, confidence calculator, suppression tracker) into the actual suggestion posting flow. Add consensus checking for critical severity. Include code graph context in fix generation prompts (FR-4.3). Suggestions that fail validation or are suppressed degrade gracefully to description-only comments. Quality metrics are captured for analytics.

Output: Complete quality gate pipeline in comment-poster with metrics integration and context-aware prompts.
</objective>

<execution_context>
@/Users/keith/.claude/get-shit-done/workflows/execute-plan.md
@/Users/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-validation-and-quality/04-CONTEXT.md
@src/github/comment-poster.ts
@src/analytics/metrics-collector.ts
@src/analysis/llm/prompt-builder.ts
@src/analysis/context/graph-builder.ts
@src/analysis/consensus.ts
@.planning/phases/04-validation-and-quality/04-01-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-03-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-04-SUMMARY.md
@.planning/phases/04-validation-and-quality/04-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation module index</name>
  <files>src/validation/index.ts</files>
  <action>
    Create barrel export for validation module:

    ```typescript
    /**
     * Validation module for suggestion quality gates.
     *
     * This module provides:
     * - Syntax validation using tree-sitter
     * - AST comparison for consensus detection
     * - Confidence scoring combining LLM + validation signals
     * - Threshold-based filtering for suggestion posting
     */

    export {
      validateSyntax,
      SyntaxValidationResult
    } from './syntax-validator';

    export {
      areASTsEquivalent,
      ASTComparisonResult
    } from './ast-comparator';

    export {
      calculateConfidence,
      shouldPostSuggestion,
      ConfidenceSignals,
      QualityConfig
    } from './confidence-calculator';
    ```

    Ensure all exports are properly typed and documented.
  </action>
  <verify>
    ```bash
    npm run typecheck
    ```
    TypeScript compiles without errors.
  </verify>
  <done>Validation module has clean public API via index.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation and consensus into comment-poster</name>
  <files>src/github/comment-poster.ts</files>
  <action>
    Add validation pipeline to postInline method with REAL consensus integration:

    1. Add imports at top:
    ```typescript
    import { validateSyntax, shouldPostSuggestion, calculateConfidence, ConfidenceSignals } from '../validation';
    import { SuppressionTracker } from '../learning/suppression-tracker';
    import { ProviderWeightTracker } from '../learning/provider-weights';
    import { detectLanguage } from '../analysis/ast/parsers';
    import { ConsensusEngine } from '../analysis/consensus';
    ```

    2. Add constructor parameters:
    ```typescript
    constructor(
      private readonly client: GitHubClient,
      private readonly dryRun: boolean = false,
      private readonly config?: Partial<ReviewConfig>,
      private readonly suppressionTracker?: SuppressionTracker,
      private readonly providerWeightTracker?: ProviderWeightTracker,
      private readonly consensusEngine?: ConsensusEngine
    ) {}
    ```

    3. Add private method for suggestion validation WITH consensus:
    ```typescript
    private async validateAndFilterSuggestion(
      comment: InlineComment & { suggestion?: string; category?: string; severity?: Severity; providers?: Array<{ provider: string; suggestion: string }> },
      prNumber: number
    ): Promise<{ valid: boolean; reason?: string; hasConsensus?: boolean }> {
      if (!comment.suggestion) {
        return { valid: true }; // No suggestion to validate
      }

      // Check suppression first (fast path)
      if (this.suppressionTracker) {
        const suppressed = await this.suppressionTracker.shouldSuppress(
          { category: comment.category || 'unknown', file: comment.path, line: comment.line },
          prNumber
        );
        if (suppressed) {
          logger.debug(`Suggestion suppressed for ${comment.path}:${comment.line} (similar suggestion dismissed)`);
          return { valid: false, reason: 'Similar suggestion was dismissed' };
        }
      }

      // Syntax validation (if enabled)
      let syntaxValid = true;
      if (this.config?.suggestionSyntaxValidation !== false) {
        const language = detectLanguage(comment.path);
        if (language !== 'unknown') {
          const syntaxResult = validateSyntax(comment.suggestion, language);
          if (!syntaxResult.isValid && !syntaxResult.skipped) {
            logger.debug(`Suggestion syntax invalid for ${comment.path}:${comment.line}: ${syntaxResult.errors.length} error(s)`);
            syntaxValid = false;
            // Don't return early - check consensus which might override
          }
        }
      }

      // Check consensus for multi-provider suggestions
      let hasConsensus = false;
      if (this.consensusEngine && comment.providers && comment.providers.length >= 2) {
        const consensusResult = this.consensusEngine.checkSuggestionConsensus(
          comment.providers.map(p => ({ provider: p.provider, suggestion: p.suggestion, file: comment.path })),
          this.config?.consensusMinAgreement ?? 2
        );
        hasConsensus = consensusResult.hasSuggestionConsensus;
        logger.debug(`Consensus check for ${comment.path}:${comment.line}: ${hasConsensus ? 'AGREED' : 'NO AGREEMENT'} (${consensusResult.agreementCount}/${comment.providers.length})`);
      }

      // If syntax invalid and no consensus to override, reject
      if (!syntaxValid && !hasConsensus) {
        return { valid: false, reason: 'Syntax validation failed', hasConsensus: false };
      }

      // Confidence threshold check
      if (comment.severity && this.config) {
        // Get provider weight for reliability signal
        let providerReliability = 1.0;
        if (this.providerWeightTracker && comment.providers?.[0]) {
          providerReliability = await this.providerWeightTracker.getWeight(comment.providers[0].provider);
        }

        const signals: ConfidenceSignals = {
          llmConfidence: (comment as any).confidence,
          syntaxValid,
          hasConsensus,
          providerReliability
        };
        const confidence = calculateConfidence(signals);

        if (!shouldPostSuggestion(
          { severity: comment.severity, providers: comment.providers?.map(p => p.provider) },
          confidence,
          {
            min_confidence: this.config.minConfidence,
            confidence_threshold: this.config.confidenceThreshold,
            consensus: {
              required_for_critical: this.config.consensusRequiredForCritical ?? true,
              min_agreement: this.config.consensusMinAgreement ?? 2
            }
          }
        )) {
          logger.debug(`Suggestion below confidence threshold for ${comment.path}:${comment.line} (confidence: ${confidence.toFixed(2)})`);
          return { valid: false, reason: 'Below confidence threshold', hasConsensus };
        }
      }

      return { valid: true, hasConsensus };
    }
    ```

    4. In postInline, after the suggestion block detection, add validation:
    ```typescript
    // After existing suggestion block detection, before posting:
    if (c.body.includes('```suggestion')) {
      const validation = await this.validateAndFilterSuggestion(
        { ...c, suggestion: /* extract suggestion content */, category: (c as any).category, severity: (c as any).severity, providers: (c as any).providers },
        prNumber
      );
      if (!validation.valid) {
        // Remove suggestion block, keep description
        c.body = c.body.replace(/```suggestion[\s\S]*?```/g, `_Suggestion not available: ${validation.reason}_`);
      }
    }
    ```

    IMPORTANT: Do NOT break existing validation logic (isSuggestionLineValid, validateSuggestionRange). Add new validation as additional layer.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="comment-poster" --verbose
    ```
    TypeScript compiles, existing tests pass.
  </verify>
  <done>Comment poster validates suggestions through quality pipeline with REAL consensus integration before posting.</done>
</task>

<task type="auto">
  <name>Task 3: Add code graph context to PromptBuilder (FR-4.3)</name>
  <files>src/analysis/llm/prompt-builder.ts</files>
  <action>
    Extend PromptBuilder to include code graph context for better fix suggestions:

    1. Add import:
    ```typescript
    import { CodeGraph } from '../context/graph-builder';
    ```

    2. Add optional codeGraph parameter to constructor:
    ```typescript
    constructor(
      private readonly config: ReviewConfig,
      private readonly intensity: ReviewIntensity = 'standard',
      private readonly codeGraph?: CodeGraph
    ) {
      // ... existing validation
    }
    ```

    3. Add method to extract relevant context for a file/line:
    ```typescript
    /**
     * Get call context from code graph for better fix suggestions.
     * Returns callers and callees for symbols near the target line.
     */
    private getCallContext(file: string, line: number): string | null {
      if (!this.codeGraph) {
        return null;
      }

      try {
        // Find symbols defined in this file
        const fileSymbols = this.codeGraph.getFileSymbols(file);
        if (!fileSymbols || fileSymbols.length === 0) {
          return null;
        }

        // Find symbol closest to the target line
        const nearbySymbol = fileSymbols
          .map(name => this.codeGraph!.getDefinition(file, name))
          .filter((def): def is Definition => def !== null && Math.abs(def.line - line) <= 20)
          .sort((a, b) => Math.abs(a.line - line) - Math.abs(b.line - line))[0];

        if (!nearbySymbol) {
          return null;
        }

        // Get callers and callees
        const callers = this.codeGraph.getCallers(nearbySymbol.name) || [];
        const callees = this.codeGraph.getCalls(nearbySymbol.name) || [];

        if (callers.length === 0 && callees.length === 0) {
          return null;
        }

        const context: string[] = [];
        context.push(`CALL CONTEXT for ${nearbySymbol.name} (${nearbySymbol.type}):`);

        if (callers.length > 0) {
          context.push(`  Called by: ${callers.slice(0, 5).join(', ')}${callers.length > 5 ? ` (+${callers.length - 5} more)` : ''}`);
        }
        if (callees.length > 0) {
          context.push(`  Calls: ${callees.slice(0, 5).join(', ')}${callees.length > 5 ? ` (+${callees.length - 5} more)` : ''}`);
        }

        return context.join('\n');
      } catch (error) {
        logger.debug('Failed to get call context:', error as Error);
        return null;
      }
    }
    ```

    4. Update build() to include call context in instructions when available:
    After the defensive context injection (around line 126), add:
    ```typescript
    // Add call context from code graph if available (FR-4.3: context-aware fixes)
    if (this.codeGraph && pr.files.length > 0) {
      // Get context for files in the diff (limit to first 3 to avoid prompt bloat)
      const contextFiles = pr.files.slice(0, 3);
      const callContexts: string[] = [];

      for (const file of contextFiles) {
        // Get context for the middle of the file as a heuristic
        const midLine = Math.floor((file.additions + file.deletions) / 2) || 1;
        const context = this.getCallContext(file.filename, midLine);
        if (context) {
          callContexts.push(`${file.filename}:\n${context}`);
        }
      }

      if (callContexts.length > 0) {
        instructions.push(
          'CODE GRAPH CONTEXT (use this to understand call relationships):',
          ...callContexts,
          ''
        );
      }
    }
    ```

    5. Export Definition type if not already exported from graph-builder.
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="prompt-builder" --verbose
    ```
    TypeScript compiles, existing prompt builder tests pass.
  </verify>
  <done>PromptBuilder includes code graph call context for context-aware fix suggestions.</done>
</task>

<task type="auto">
  <name>Task 4: Add quality metrics to analytics</name>
  <files>src/analytics/metrics-collector.ts</files>
  <action>
    Extend MetricsCollector to track suggestion quality metrics:

    1. Add interface for suggestion metrics:
    ```typescript
    export interface SuggestionQualityMetric {
      timestamp: number;
      prNumber: number;
      file: string;
      line: number;
      syntaxValid: boolean;
      suppressed: boolean;
      hasConsensus: boolean;
      confidenceScore: number;
      posted: boolean;
      reason?: string;  // Why not posted (if !posted)
    }
    ```

    2. Extend MetricsData:
    ```typescript
    export interface MetricsData {
      reviews: ReviewMetric[];
      suggestionQuality: SuggestionQualityMetric[];  // NEW
      // ... existing fields
    }
    ```

    3. Add method to record suggestion quality:
    ```typescript
    async recordSuggestionQuality(metric: Omit<SuggestionQualityMetric, 'timestamp'>): Promise<void> {
      const data = await this.loadData();

      data.suggestionQuality = data.suggestionQuality || [];
      data.suggestionQuality.push({
        ...metric,
        timestamp: Date.now()
      });

      // Keep only last N suggestion metrics
      const maxSuggestions = (this.config?.analyticsMaxReviews || 1000) * 10; // 10x reviews
      if (data.suggestionQuality.length > maxSuggestions) {
        data.suggestionQuality = data.suggestionQuality.slice(-maxSuggestions);
      }

      await this.saveData(data);
      logger.debug(`Recorded suggestion quality metric for ${metric.file}:${metric.line}`);
    }
    ```

    4. Add method to get suggestion quality stats:
    ```typescript
    async getSuggestionQualityStats(): Promise<{
      totalSuggestions: number;
      syntaxValidRate: number;
      suppressionRate: number;
      consensusRate: number;
      avgConfidence: number;
      postRate: number;
    }> {
      const data = await this.loadData();
      const suggestions = data.suggestionQuality || [];

      if (suggestions.length === 0) {
        return {
          totalSuggestions: 0,
          syntaxValidRate: 0,
          suppressionRate: 0,
          consensusRate: 0,
          avgConfidence: 0,
          postRate: 0
        };
      }

      const syntaxValid = suggestions.filter(s => s.syntaxValid).length;
      const suppressed = suggestions.filter(s => s.suppressed).length;
      const hasConsensus = suggestions.filter(s => s.hasConsensus).length;
      const posted = suggestions.filter(s => s.posted).length;
      const totalConfidence = suggestions.reduce((sum, s) => sum + s.confidenceScore, 0);

      return {
        totalSuggestions: suggestions.length,
        syntaxValidRate: syntaxValid / suggestions.length,
        suppressionRate: suppressed / suggestions.length,
        consensusRate: hasConsensus / suggestions.length,
        avgConfidence: totalConfidence / suggestions.length,
        postRate: posted / suggestions.length
      };
    }
    ```

    5. Update loadData to handle missing suggestionQuality array (backward compatibility).
  </action>
  <verify>
    ```bash
    npm run typecheck && npm test -- --testPathPattern="metrics" --verbose
    ```
    TypeScript compiles, existing metrics tests pass.
  </verify>
  <done>Quality metrics for suggestions are tracked in analytics system with consensus tracking.</done>
</task>

</tasks>

<verification>
```bash
npm run typecheck && npm test --verbose
```
- All TypeScript compiles
- All tests pass
- No regressions in existing functionality
</verification>

<success_criteria>
- Validation module has clean exports via index.ts
- CommentPoster validates suggestions before posting
- Consensus engine is WIRED (not TODO) for suggestion agreement
- PromptBuilder includes code graph context (FR-4.3)
- Invalid/suppressed suggestions degrade to description-only
- Quality metrics captured for analytics dashboard
- Existing comment posting behavior unchanged for non-suggestion comments
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation-and-quality/04-06-SUMMARY.md`
</output>
